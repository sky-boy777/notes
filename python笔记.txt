安装：pip install -r requirements.txt
导出：pip freeze > requirements.txt

pip download -r requirement.txt -i https://pypi.douban.com/simple/      下载whl文件到当前目录
pip install --no-index --find-links=./whl文件目录 -r requitements.txt        安装whl文件

python的传递都是内存地址或引用传递

select、poll、epoll：
监管
IO多路复用，轮询

异步IO模型：
效率最高的，速度快
模块：asyncio  # 单线程实现并发
异步框架：sanic、 tronado、 twisted

同步与异步：
任务的提交方式

阻塞与非阻塞：
程序的运行状态

OSI七层:
应、表、会、传、网、数、物

四层：
应
传
网际层
网络接口层
*******************************************
五层：
应                  http/s、ftp
传                  tcp、ip                   段
网络层           IP协议                     包
数                  以太网协议              帧
物

包：头head+数据data，一层层加头：以太网头+ip头+tcp头+应用层头+应用层数据
ARP协议：将IP地址解析成mac地址
端口port：0~65535
IP+mac地址：唯一标识一台计算机，加端口号能唯一标识一台计算机的应用
路由协议

tcp三次握手：
1、请求                               SYN  seq=x
2、确认+请求                      ACK=x+1，SYN seq=y
3、确认                               ACK=y+1

A发送SYN为1请求连接，B收到返回SYN跟ACK都为1表示收到并请求连接，
       A返回ACK为1通知B双方以完成连接建立。有超时重传机制

SYN洪水攻击

tcp四次挥手：
1、fin
2、ack
3、fin
4、ack

对称释放方式，A发送FIN为1表示，B收到通知应用程序会话已结束，返回ACK为1
       应答，B发送FIN为1，A收到返回ACK为1的应答给B，A端time_wait两倍报文段寿命（2MSL）后关闭。

tcp拥塞控制：慢启动、拥塞避免、快速重传、快速恢复。流量控制：滑动窗口

tcp可靠，效率慢，udp不可靠，快，实时性较高时使用

DNS：
递归查询
迭代查询
**********************************************

用户画像：
就是用户的行为，搜索过哪些商品，看过什么等

http：
基于tcp
浏览器跟服务器传输（请求与响应）

epoll：
轮询，事件通知，一个共享空间
nginx使用，linux使用

进程、线程、协程：
进程是资源分配的单位
线程是操作系统调度的单位
进程切换需要资源很大，效率很低
线程切换需要的资源一般，效率一般（在不考虑GIL的情况下）
协程切换任务资源很小，效率高
多进程、多线程根据cpu核数不一样可能是并行的，但协程是在一个线程中，所以是并发

进程池、线程池：
大量任务要执行时，创建一堆进程，形成进程池 (不用的时候休眠，就不会有销毁)
优点：重复利用，减少创建和销毁的开销
使用：一般在测试时进行压力测试使用
会降低效率，因为池满后只能排队

线程池中线程数：系统没什么压力，简单的异步场景使用cpu核心数，适当增加

from multiprocessing import Pool      
if __name__ == '__main__':
pool = Pool(5)             # 进程池，最多5个进程
for i in range(8):           # 8个任务，多出来的排队等待
    pool.apply_async(fun, args=(参数, )，callback=回调函数)        # 非阻塞式，返回值给callback
    # pool.apply(fun, args=(参数，))                                           # 阻塞式，并发，一个不结束，另一个不能进来
pool.close()   关闭
pool.join()     # 主进程守护


concurrent.futures包很快，可以处理线程和进程


开放封闭原则：
封闭:已实现的功能代码块
开放：对扩展开放

浏览器访问一个url过程：
域名解析
通过IP找到服务器建立tcp连接
返回响应
浏览器渲染
关闭tcp连接

垃圾回收机制(GC)：
CPython解释器实现
变量名存地址
内存：变量存在栈区，值存在堆区
1、引用计数：值有零个变量引用就会回收，访问不到了。手动减少计数：del 变量名。
2、标记清除：解决相互引用(循环引用)带来内存泄漏，引用计数一直不能为0。
3、分代回收：CPython2.0增加，用于检测引用循环中涉及的对象组，给一个权重，
     高的会隔很长时间才扫描一遍，解决引用计数的每次全部扫描缺点，但不能及时回收垃圾。

del语句删除名称，而不是对象。对象引用计数归零，则被垃圾回收。

open(xx).write(xx)    # 是安全的，write()返回后会立即被垃圾回收

python多进程是真正的并行

http协议：请求和应答

进程间通信：
1、管道：无名管道、命名管道、高级管道
2、消息队列
3、内存映射(共享内存)
4、socket(套接字)，可用于不同机器间的进程通信
5、信号量
6、信号

封装、继承、多态：python可以多继承


算法时间复杂度的排序比较：
O(1)<O(log*n)<O(n)<O(n log n)<O(n方)<O(c n次方)<O(n!)<O(n n次方)
平均时间：
list：追加，取值，赋值都是O(1), 插入删除某个元素则是O(n)
set:   x in s 为O(1)
dict:  修改删除元素的值为O(1), 迭代操作为O(n)


循环的优化：
尽量减少循环过程中的计算量，多重循环下尽量将内存的计算提到上一层
1、减少内部循环的计算
2、将显示循环改为隐式循环
3、在循环中尽量引用局部变量，局部变量优先搜索，j = json.dump, v = v1[i]

GIL：
全局解释器锁
Cpython，互斥锁，同一进程下多个线程不能同时执行，无法利用多核优势
GIL锁跟Cpython解释器有关，跟python语言无关，Cpython使同一时刻只能有一
个线程在cpu执行（上锁）只能是并发。多核cpu使用进程就是并行
进入IO，GIL会自动释放。如time.sleep()会释放GIL。

python线程在I/O密集型应用中能发挥作用

互斥锁：逻辑上避免线程间死锁

深拷贝：全部数据拷贝过来。
浅拷贝：拷贝最上层数据过来，再深层的是指向。list(列表)、my_list[:] 都是浅拷贝
赋值：只是指向，浅拷贝跟深拷贝一个元组则是指向，如果元组里面有列表，则深拷
贝就是深拷贝，浅拷贝还是指向。

元组tuple中： t[:], tuple(t), copy.copy()返回的都是对象的引用，str、bytes、frozenset也一样返回对象引用

a = 'abc'
b = 'abc'
a is b                # 返True，这是CPython的一种优化措施，共享字符串字面量，称为驻留，一些小的整数也是 
                           这样，为了防止重复创建常用的数字

+=、*= 这类，如何左边变量是不可变对象，则会创建一个新对象，否则就地修改

deepcopy能解决循环引用：
a = [1,2]
b = [a,3]
a.append(b)
print(a)            # 输出 [1, 2, [[...], 3]]


服务器（nginx）----WSGI协议--------web应用（django）


------------------------------------------------------------------------
python进程：
进程是程序运行的实体
稳定性高，一个进程崩溃，不会影响其它进程
进程创建开销大
内存中申请内存空间，把代码丢进去运行，资源单位
windows下创建进程会导入包含了目标函数的脚本文件，要在if __name__ == '__main___'下面，
才不会导致无限循环创建进程
linux下是重新拷贝一份代码运行，不会出现这种问题

创建进程：
from multiprocessing import Process
p = Process(target=fun, args=(a,))
p.start()           # 告诉操作系统创建进程
p.join()            # 主进程等待子进程执行结束才继续运行
p.terminate()  # 杀死当前进程
p.is_alive()      # 判断进程是否存活
p.daemo = True  # 设置为守护进程
p.run()            # 只是执行了任务，没有创建进程

自定义类然后继承自Process也可以创建进程，重写run方法
os.getpid()  # 查看当前进程的进程号
os.getppid()  # 父进程号

孤儿进程：子进程存活，父进程死亡
守护进程：守护着某个进程，跟随它死亡
互斥锁：使用前先加锁，牺牲效率，并发变成串行，保证安全

线程：
执行单位，新建----（就绪，运行，阻塞）----结束
同一个进程下多个线程共享进程资源
from threading import Thread

t = Thread(target=fun, targs=(参数，))  # 创建
t.start()             # 开启
t.join()              # 主线程等待子线程结束才结束
t.active_count()  # 统计当前正在活跃的线程数
t.daemon()      # 守护线程：主线程等待所有非守护线程结束才结束

多线程同步：
数据量大的时候加锁，量少的时候有GIL锁
线程间通信：生产者消费者（队列）
lock = threading.Lock()
lock.acquire(timeout=5)     锁，超时时间
......                   执行任务
lock.release()   释放锁


协程：
单线程下实现并发，在代码层面的切换，程序遇到IO后在代码层面切换，yield切换
gevent模块：
greenlet实现了协程，需要人工切换，而gevent模块一旦遇到IO则自动切换任务
pip insatll gevent

from gevent import monkey;monkey.patch_all()      # 猴子补丁，替换sleep，简写加分号
from gevent import spawn

g = spawn(fun，其它参数)
g.join()  # 主进程等待，或gevent.joinall(g, g1, g2...)

计算密集型用进程
IO密集型用线程，因为线程切换开销小，进程切换开销大

****一般多进程下面开多线程下面开协程


asyncio内置包：      
https://docs.python.org/zh-cn/3.7/library/asyncio-task.html
异步I/O, 协程通过async/await语法声明，async表示定义异步函数，对象可在await语句中使用
那么它就是可等待对象，如协程、任务、Future
使用事件循环驱动的协程实现并发
import asyncio

async def main():
    print('hell')
    await asyncio.sleep(1)
    print('worl')

asyncio.run(main())   # 运行协程的方式

------asyncio.create_task()  用来并发运行作为asyncio任务的多个协程
async def s(s, num):
    await asyncio.sleep(num)
    print(s)

async def main():
    t1 = asyncio.create_task(s('hello', 1))
    t2 = asyncio.create_task(s('world', 2))
    await t1
    await t2

asyncio.run(main())

aiohttp包是异步网络请求，而requests是同步的


递归锁：
所有人都可以加锁跟释放锁，里面会有个计数器，加锁+1，释放-1，但只能有一个人能执行

log日志：
五个级别，低---高
1、debug  详细信息
2、info   按预期运行
3、warning  警告
4、error  错误
5、critical  严重错误
一般是：年月日时分秒 哪个文件 第几行 日志级别 信息


元类：
元类是用于构建类的类
在创建类的时候给它加功能，相当于装饰器最顶层，元类创建类，是类的类，元类创建元类
元类--->类--->实例对象

type就是一个元类，创建类：
myclass = type('MyClass', (MyClass继承的类, ), {'a':1, 'b':2, 'fun': 实例方法，静态方法...})
等价于：
class MyClass: 
    a=1
    b=2

所有类都是type的实例，但是元类还是type的子类


globals()可以查看所有全局对象(函数、变量、类等)的引用，返回的是字典
a=1
def a():
    pass

a会覆盖，指向一个函数

ORM：
对象--关系，映射，django核心
数据库：类名对应表名，类属性对应字段
解决不用手写SQL

is：比较对象的地址值(id())
==：比较l两个对象的值，a.__eq__(b), object对象的__eq__方法同is一样比较id值，但其它内置类型覆盖了这个方法

元组中不可变的是元素的id，而元素引用的对象可以是可变的

str、bytes、array.array是在连续的内存中保存数据本身（字符，字节，数字）

''    False
' '   True, 一个空格 
-----------------------------------------------------------------

面向对象：
提升程序解耦合度，扩展性增强
缺点：设计复杂

class AA([父类]):                                  # 定义类，驼峰命名
    """这是一个类"""
    
    name = 'xxx'                                  # 类属性   
    __age = 18                                    # 私有，两个下划线开头且尾部最多有一个下划线，存放在实例的__dict__属性中：_AA__age，方法也是一样。
    
    def __init__(self，age, name):           # 初始化方法，双下划线开头结尾：魔法方法

        super.__init__(name)                      # 方法一，调用父类__init__初始化方法
        super.(AA, self).__init__(name)       # 方法二
        父类.__init(self, name)                    # 方法三，使用父类名直接调用

        self.age = age                           # 实例属性
        self.__xxx = xxx                          # 私有

    def fun(self):                                  # 普通方法
        super().fun()                               # 调用父类的方法，同名
        self.run()                                   # 调用方法

    def __method(self):                        # 私有方法
        pass

    @classmethod
    def fun(cls):                                # 类方法，类来调用，类方法里面只能使用类属性, fun = classmethod(fun)
        cls.xx = xx                              # 类属性
        cls.__age = 19                       # 修改私有类属性，只能在类里面更改

    @staticmethod
    def func():                              # 静态方法，只能访问类的属性跟方法, func = staticmethod(func)
        类名.属性或方法

    def method():
        return 'aaa'
    
    @property                                                   # 推荐使用装饰器的形式
    def name(self):
        """这里会是property的doc参数的文档"""     #  doc参数值
        return self.__name 

    method = staticmethod(method)      # 也可以这样定义，staticmethod跟classmethod都是类
    name = property(fget=name)           # property也是类，四个参数：对应获取，设置，删除，文档
                                                            # property(fget=None, fset=None, fdel=None, doc=None)
    

obj = 类名()  　# 实例化
obj.方法()      # 使用方法
obj.xx = 'xx'   # 添加对象属性
类名.属性       # 查看类属性
类名.类方法()   # 使用类方法
类名.静态方法() # 使用静态方法

在类上调用方法相当于调用函数：Class.fun(obj)         # obj就是方法的参数self，实参可以是其它
type(Class.fun)                                                      # 函数
type(obj.fun)                                                         # 方法  
obj.fun()       <==>       Class.fun.__get__(obj)        # 返回对应绑定的方法
 
一般使用一个前下划线说明是私有属性，跟用全大写表示常量一样，是一种约定。

A.__base__                             可以查看A的父类，A.__bases__  输出多继承的几个类
a.__class__                             查看a属于哪个类, 等同于type(a)
issubclass(A, object）            判断类A是否是object的子类
isinstance(a, A)                      判断一个对象是否是一个类的实例     
type(a)                                   也可以查看一个对象所属的类

from 模块 import *         # 不会导入以一个下划线开头的名称，跟两个下划线一样，这也是一种私有
import inspect               这个模块让用户能够以图形方式浏览python对象的程序
import abc                     模块提供抽象基类（不能实例化，只能继承的类），跟java一样，子类必须实现父类的所有抽象方法
import collections         模块

同一个类里有多个相同的方法，后面的会覆盖前面的

实例化发生的事：
1、造一个空对象, __new__方法
2、执行__init__方法
3、返回初始化好的对象，__call__方法

类能向上找到元类,对象不能向上找到元类

魔法方法：
双下划线开头和结尾，满足某种条件会自动调用: __init__(self)读作：双下-init, 双下方法
一般只有python的解释器会频繁直接调用魔法方法
80几个魔法方法

def __new__(cls, *args, **kwargs)    # 实例化的魔法方法，向内存申请空间,单例设计模式使用到
    return super().__new__(cls)

__init__(self)         # 初始化，重写时需要调用父类的__init__方法，不然可能会发生意外
__str__（self）      # print打印对象会执行，返回字符串， return 'str方法'， str()
__dict__               # 一个映射，存储对象或类的可写属性
__del__                # 也称析构函数，在del对象时会先执行(垃圾回收)，del obj或程序运行结束之前释放内存件
__call__(self)        # 使对象能加括号调用，类似函数，例：obj = Obj(), obj()
__doc__                 # 属性
__len__(self)           # len(x), x是内置类型时速度会非常快，CPython会直接从一个C结构体读取对象的长度，不会调用任何方法。
__repr__(self)         # 内置函数repr()，将对象用字符串表示出来
__add__(self)          # '+' 加法，对不可变序列做重复拼接效率会很低，每次都重新赋值，str是例外，CPython做了优化
__iadd__(self)         #  '+='  可变序列使用则就地加法，地址不变。不可变序列内部没有实现__iadd__, 而会调用__add__，会重新赋值
__mul__(self)          # '*'  乘法
__bool__(self)        # bool()，类中不存在这个方法则会调用__len__(), 为0则返回False
__slots__               # 限制实例能有哪些属性，使用得当，能节省内存
__enter__(self) 和 __exit__(self)      # 上下文管理with

就地加法：
t = (1, 2, [3, 4])
try:
    t[2] += [55]
except:
    pass
print(t)                        # t变成(1, 2, [3, 4, 55])，并且会抛出：TypeError: 'tuple' object does not support item assignment，元组不支持项赋值
t[2].extend([33,44])     # 则不会抛出以上异常

import dis
dis.dis('s[a] += b')            # 在控制台中输入背后的字节码

序列和映射                                     
__getitem__(self, key)                     字典d['key'] 背后就是__getitem__方法：d.__getitem__('key')    
__setitem__(self, key, value)
__delitem__(self, key)
__missing__(self，key)                           在d[k]没有取到值的时候返回一个默认的值，dict中没有实现这个方法

属性相关
__getattribute__(self, name)       属性被访问时自动调用（只适用于新式类） 
__setattr__(self, name, value)     试图给属性赋值时自动调用
__delattr__(self, name)               试图删除属性时自动调用

__getattr__(self, name)              在属性被访问而对象没有这样的属性时自动调用, 只在对象的类中寻找，而不在实例中寻找
这几个方法效率比property低
       
新式类：继承自Object，python3默认继承自Object
经典类：不继承Object，python2

私有，只有类内能使用，对外不对内，外界不能访问、子类也不能访问，继承不了，dir()看到变形后的
类定义时变形才发生一次，之后定义的双下划线开头的属性就是普通属性
私有属性：self.__age = 18
私有方法：def __fun(self)：
双下划线，不是真正意义上的私有
访问：实例对象._类名.__属性名或方法

为何要私有：
不私有的话，代码提示或外界会看到很多属性跟方法，会变得复杂
不想给外界直接使用，只能在内部开接口间接使用，可以在使用前附加逻辑

外部访问：对象._类名__属性名,变形后的私有属性

property：特性都是类属性，但是特性管理的其实是实例属性

property是类
class B:
    def get_name(self):
        return 'b'

    def set_name(self, name):
        self.name = name

   def del_name(self):
        del self.name

    name = property(fget=get_name, fset=set_name，del_name, "文档字符串")    # property，能把函数当作属性来使用，使不必用set_name(), get_name()这类存取方法

b = B()
b.name                      获取
b.name = 'aaa'          设置
del b.name                删除
B.name.__doc__         文档字符串

@property：
类实现的装饰器，将方法当成属性使用

使用方式：@property或老版本name = property(get_name(), set_name())
@property
def name(self):          # 先使用property装饰，能使用obj.name获取，才能使用下面的
    return self.__age

@name.setter           # 能使用obj.name = '张三'
def name(self, age):
    if age:
        self.__age = age
    
@name.deleter         # 能使用del obj.name
def name(self):

is a 代表的是类之间的继承关系
has a 代表的是对象和它的成员的从属关系，同一种类的对象，通过它们的属性的不同值来区别

调用父类方法：
super().父类方法     例：super().__init__()  # 参照属性最先发起者的mro顺序，新式类
父类名.方法(obj, name, age)  

继承的属性查找：
类名.__mro__          查看父类的方法解析顺序，C3算法计算继承顺序，形成一个列表
先从当前对象找，然后到父类找，而不是就近查找

新式类：广度优先查找，一条分支一条分支找，最后才是object，python3是广度优先
经典类：从左至右，深度优先查找

菱形继承或钻石：
    A           爷爷类，不是object类
B       C       父类
    D           子类

非菱形：
A     B
C     D    E
      F

继承：
解决类与类之间的代码冗余问题，重用
python支持多继承
obj.__bases__查看继承的类

多继承：
优点：可以同时继承多个父类的方法跟属性，最大限度的重用代码
缺点：代码可读性变差，违背人的思维习惯，扩展性变差，引发菱形问题

多继承的正确打开方式--mixins机制：
使用一个核心超类，多个混合超类
尽可能提升多继承的可读性
是一种规范，在定义类时在后面添加MixIn，表示是混入的一些东西、功能，提升可读性
例：
class UserMixIn：
    pass

处理多重继承避免把类图搅乱的一些建议：--流畅的python
1、把接口继承和实现继承区分开
2、使用抽象基类显示表示接口
3、通过混入重用代码，混入类（mixin class），混入的类不实例化，只提供方法
4、在名称中明确指明混入，...Mixin作后缀
5、抽象基类可以作为混入，反过来则不成立
6、不要子类化多个具体类，一个核心超类，多个混入类或抽象基类
7、为用户提供聚合类，全是混入类，没有具体类
8、优先使用对象组合，而不是类继承


多态：
前提：继承、重写父类方法
同一种事物多种形态，不同子类调用相同父类方法产生不同结果
方便使用者
一种编程思想

多态的体现：count， +号
'abc'.count('a')
['a', 'b', 'c'].count('a')
1 + 2
'aa' + 'bb'

反射机制：
程序运行过程中可以动态获取对象的信息
obj是对象，类
getattr(obj，'age', default)        # 获取对象age属性值，可能来自类或超类，无则返回默认值，没有默认值抛出AttributeError异常
hasattr(obj, 'age')                    # 判断obj对象下是否有属性age，布尔值。其实是是调用getattr(obj, 'obj')看看是否抛出了AttributeError异常
setattr(obj,  'age'， 18)            # 给对象设置属性，覆盖或创建
delattr(obj, 'age')                     # 删除
例子：
getattr(obj, 'fun')()                   # 获取obj对象的fun方法，并执行


类在内存中只有一份，实例对象有很多个
类属性：aaa = 'bbb'，使用：类名.类属性，实例对象.类属性（不推荐），向上查找
类方法：
@calssmethod
def 类方法名(cls):   # cls代表类，self代表实例对象
    cls.类属性    # 调用类属性
    cls.类方法    # 调用类方法
使用：类名.类方法

静态方法：
谁都能调用，不使用到实例属性跟类属性，使用静态方法
@staticmethod
def 静态方法():
    pass

调用：类名.静态方法

元类：
一切皆对象
父类不是元类
是类的类type，是
class Obj <=> Obj = type('Obj', (object,), {...})
例子：
class mymeta(type):  # 继承了type，称为元类
    pass

class Obj(metaclass=mymeta):
    pass

-------------------------------------------------------
单例设计模式：
一种开发模式
只有唯一 一个实例对象，无论实例化多少个对象，内存地址都是相同的，省内存

__new__方法，返回对象的引用
def __new__(cls, *args, **kwargs):
    obj = super().__new__(cls)   # 固定写法，返回super().__new__(cls)
    return obj

重写父类的__new__方法实现单例模式：
class Obj():
    __obj = None  # 保存单例的地址
    flag = False     # 定义一个标志，只执行一次初始化动作__init__

    def __new__(cls, *args, **kwargs):
        if cls.__obj is None:
            cls.__obj = super().__new__(cls)  # 也可以使用object.__new__(cls)
        return cls.__obj                               # 每次实例化对象都返回第一次实例的对象的引用

    def __init__(self):                                 # 单例应该只初始化一次
        if Obj.flag:
            return
        # 执行初始化动作
        ......
        # 将初始化标志置位True
        Obj.flag = True
------------------------------------------------------
python内置函数：
在builtins.py文件里面

a = [1,2]
type(type(a)) == <class 'type'>

from functools import reduce
res = reduce(lambds x，y：x+y, 可迭代对象，初始值(给第一个x))  # 将可迭代对象的每一个元素交给匿名函数运算

map(func, 可迭代对象)                    得到生成器对象，list（map(func, 可迭代对象)）得到列表
filter(func, 可迭代对象)                    过滤，返回生成器对象，结果需要转换为列表
all()                                                全部为真返回True否则False, all([])返回True，all({})True
dir（obj）                                        列出对象的属性、方法，当前作用域，不会列出__dict__、__mro__、__bases__、__name__
divmod（10，3）                            计算商跟余数，返回（商，余数）
isinstance（obj，Obj）                   类型判断，判断一个对象是否是一个类的实例，isinstance(2,int) True
zip（[1,2], [3,4]）                             拉链函数，[(1,3), (2,4)]
time = __import__('time')                 导入time模块
abs（）                                             绝对值
any（）                                            有一个为真返回True, any([])返回False，any({})False
bin（）                                             2进制
oct（）                                             8进制
hex（）                                            16进制
bool('1'）                                         转换为布尔值, True + False + 3 = 4
callable（函数，类...）                    判断是否可调用
chr（65）                                        ASCII，返回一个字符串
ord（'A'）                                       ASCII，接收一个字符，返回一个数字
enumerate（[1,2,3]）                    枚举下标跟值
eval（）                                          执行字符串中的表达式
frozenset（{1，2，3}）                   不可变集合
hash（）                                       得到哈希值
pow（10，2，3）                          平方，10的平方求余3
round（1.4）                               四舍五入为指定精度，返回整数，正好为5时，舍入为偶数，round(1.5)返回2，round(0.5)返回0
slice（1，4，2）                       切片
sum（）                                    求和
help(对象)                                查看帮助信息
globals()                                   返回全局变量的一个字典，只能访问，不能设置
locals()                                      返回局部变量的一个字典，locals()['a']，只能访问，不能设置

x = 1
a = vars()                                 无参数则跟locals()一样，返回本地作用域
vars(obj)                                  指定obj，返回obj对象的__dict__属性

排序依据字典value：
res = sorted(dic, key=lambda k: dic[k])     # 按照关键字key排序，任何可迭代对象，不可变元组做参数，都返回一个新列表
res = sorted(list, key=len， resverse=True)    # 按照元素长度降序排序，sorted是稳定排序

bisect模块：实现了二分查找法
bisect.insort(有序列表， 4)           # 将4插入列表，并保持列表有序


垃圾回收机制：引用计数、标记清除、分代回收
sys.getrefcount(对象)      查看被引用次数

转为二进制：bytes('hello', encode='utf-8'）

python 三元表达式 ： a = 'b'  if  x>y  else  'c'

列表推导式：[表达式 for i in 列表 if 条件 for j in...]         #  可以多层嵌套，在外面再使用 i 会报错，因此不会导致变量泄露
字典推导式：  {key: value for key,value in dic.items()}
集合推导式：  {i for i in range(10)}
得到一个生成器：（i for i in range(10)）        # 生成器表达式，用到再产生元素，更节省内存
没有元组推导式，因为元组不可变

列表推导会及早求值，与惰性求值相反

if True:     <==>    if True:
    pass                       "xxx"           # 使用字符串做占位符

两个函数：
exec("print('a')")        将字符串作为代码执行，无返回
a = eval('3+4')           计算表达式并返回

del                             不能删除值，只删除了变量名


--------------------------------------------------------------------------------------
内置可迭代的对象：生成器，列表，元组，字典，集合，str
from collections import Iterable
isinstance(list1, Iterable)              # 判断对象是否是可迭代的

for i in list:     背后隐式调用iter(list), 这个函数背后则是list.__iter__()方法, 前提是list里面实现了__iter__()方法

iterable：可迭代的
iterator：迭代器

迭代器（Iterator）：
迭代器是访问集合元素的一种方式，迭代器是一个可以机制遍历的位置的对象。
迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。
可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator

特点：
迭代器只能往前不会后退，可以不依赖索引取值
实现了__iter__方法的称为可迭代对象，可以使用for循环
实现了__next__方法称为迭代器，next(it)调用一次返回一个值
缺点：迭代器对象不能按索引取值，不能倒退，有生命周期，取完值就没了

可迭代对象：__iter__
迭代器：__iter__ + __next__

it = iter([1, 2, 88, 55])               # 从可迭代对象获取一个迭代器

迭代器使用next()函数取值
item = next(it)  <==> it.__next__()      # __next__()没有更多值可迭代时，引发异常：StopIteration

所以可迭代对象不一定是迭代器，生成器一定是迭代器

实现__getitem__方法的对象也是可迭代的对象

使用迭代器实现斐波那契数列，需要时计算，不必一下存入列表占用大量内存
class F:
    def __init__(self):
        self.a = 0
        self.b = 1

    def __next__(self):           # 调用next(obj), 或obj.__next__()，取数
        self.a, self.b = self.b, self.a + self.b
        if self.a > 10000:
            raise StopIteration        # 停止
        return self.a

     def __iter__(self):      # 实现了这个方法，返回一个迭代器，使可以使用：for i in obj:
        return self            # 返回调用者自身
    
f = F()
for i in range(40):
    print(next(f))

for i in f:      # 只用定义了__iter__(self)方法，才可以这样使用
    print(i)

l = list(f)     # 转换成列表

生成器：
生成器是一种迭代器，yield让代码挂起(暂停)，下次从挂起位置继续执行，yield后默认返回None
用到的时候再生成，节约内存

创建生成器：
方式一：
将列表推导式的括号改为小括号，称为生成器表达式，或生成器推导，是语法糖
g = (i for i in [1, 2, 3])           # 创建一个生成器
next(g)                                 # 取值，内置函数取值，一次产生一个值，取不到会报错
g.__next__()                          # 取值，一次产生一个值，取不到会报错

方式二：
函数里面包含yield关键字语句的称为生成器
def func():
    for i in [1, 3, 5, 9]:
        x = yield i                     # 函数中出现yield关键字，则会返回一个生成器
        print(x)

g = func()                           # 调用函数返回值是一个生成器，函数体代码不会执行
v1 = g.__next__()                # 执行__next__()方法得到yield后面的值，或next(g)
v2 = g.send(None)             # 值传给了x ，生成器刚启动时只能传None值，send返回一次next的值
v3 = g.send('值')
l = list(func())                     # 转换为一个列表
g.close()                            # 关闭后无法send()传值
g.throw(Exception)            # 用于在生成器内部抛出异常


yield from 句法：              可以用于简化循环中的yield
def fun():
    yield from 'ab'          # 子生成器, yield from x  第一件事就是调用iter(x), x可以
    yield from '12'          # 是任何可迭代对象。PEP 380：把职责委托给子生成器 


print(list(fun()))             # ['a', 'b', '1', '2']

句法：
sum(i for i in range(10))     # 求和，内部不需要小括号，函数有其它参数则必须要加

for i in 可迭代对象，循环调用__iter__()得到迭代器对象，每次调用__next___()返回一个值给i

只有for循环迭代时，才执行生成器函数体。

生成器应用：协程（交替执行，并发）

with open('aa.txt', 'r') as f:
    g = (i for i in f)     # 生成器方法读取文件，效率最高

生成器应用递归：
将多维列表转为一维
def fun(l:list):
    try:
        for i in l:
            if type(l) == str:           # 处理字符串
                raise Exception('处理字符串')
            for j in fun(i):
                yield j
    except Exception as e:    # 如果l不是一个列表则会捕获异常，并返回
        yield l

g = fun( [1,2,[3, 4, 'ab', ['bn']]] )
print(list(g))         # [1, 2, 3, 4, 'ab', 'bn']


os.walk(top='路径')      # 生成器函数，遍历目录树的过程中产出文件名


itertools:
内置生成器模块, 提供了19个生成器函数
g = itertools.count(start, step)       # 无限生成，无参数则从默认0，步长1
g = itertools.takewhile(lambda n: n < 3, itertools.count(1, 1))   # 小于3
next(g)
g = itertools.groupby('aabbccddd'，key=func)        # (key的分组标准，生成器)，（'a', ['a', 'a']）


with open('4.jpg', 'rb') as f:
    for i in f:
        print(i)    # 判断是否是图片，第六位后面的字母JFIF，b'\xff\xd8\xff\xe0\x00\x10 JFIF   \x00\x01\x     
        break

--------------------------------------------------------------------------------------------
上下文管理器和with块：
1、with语句会设置一个临时的上下文，交给上下文管理器对象控制，并且负责清理上下文。
2、上下文管理器协议包含__enter__和__exit__两个方法，with语句开始时，在上下文管理器对象
调用__enter__, 结束时调用__exit__方法

with块没有定义新的作用域

with open('a.txt','r') as f:         # 在上下文管理器调用__enter__方法，结果返回给f变量
    pass


else在for、while、try中：
for：         # 仅当for循环运行完毕时（没有被break语句终止）才运行else
while：     # 仅当while循环移位条件为假而退出时（没有被break语句终止）才运行else
try：         # 仅当try块中没有异常抛出时才运行else


---------------------------------------------------------------------------------------------
递归：
python递归默认是1000层，可以修改
两个阶段：
1、回溯：一层层调用下去
2、递推：满足某种条件，结束递归，一层层返回
def sum(n):
    if n==0:          # 递归出口
        return 0
    return n+sum(n-1)  # 累加求和


数字类型int与float：
int(1.23) <=> 1
int('1.23') 会报错，不能直接将字符串小数之间转为整型
float('1') <=> 1.0
bin(10)  转二进制
oct（10） 转八进制 0o33
hex（10）转十六进制 0xd
复数：x = 10 + 3j

字符类型str：
不可变类型，str(任何类型)，str对象中获取的元素是Unicode字符
按索引取值，正取0，倒取-1，只能取不能赋值
切片[1:-1: 2]       反向步长[1:5: -1]得到为空  ，倒着走[5:1:-1]
长度len(s)
成员运算in 与 not in
s.strip('#')                                  去除左右两边字符，默认空格，可以多个，s.lstrip（''）左边空格、s.rstrip（''）右边空客
s.split('字符'，次数)                      切割成列表，默认空格分割，s.rsplit('xx')   从右边切割
判断开头结尾：startswith('xx')、endswih('xx')
''.join(列表)                                   拼接，只能是字符
s.replace('aa', 'bb', 次数)              aa替换为bb
s.isdigit()                                      判断字符串是否由纯数字组成，阿拉伯数字。isnumeric()能识别'4'、'四'、'IV'
s.find('abc'，2, 5)                         查找，返回第一个字符a的索引，否则返回 -1，指定起始位置2，5，左闭右开
s.rfind()                                        从右边开始
s.index('值')                                 返回索引, rindex()
s.count('值')                                值出现的次数
s.isalpha（）                               是否是字母
s.center(10, '#')                            居中，两边填充#号。左对齐ljust，右对齐rjust
s.lower('A#%A')                            字母转为小写，upper()  ,istitle()如果开头大写，title(), islower()如果全部小写
s.isidentifier()                               判断是否为有效标识符（变量）

max('aab')   最大
min('aab')   最小

冒号后面使用转换的类型：
b 二进制
c  Uniconde码点, 
d  整数, 
e, E, 
f浮点数, F, 
g, G，n, 
o    八进制
x十六进制, X 
%   百分比表示
s = '{name}aa{num:.2f}'.format(name='a', num=4)                     命名格式字符串：aaa4.00
s = '{name[1]}---{obj.name}'.format(name=['1', '2']，obj=obj)   使用列表，或对象

转换标志s、r、a表示用str、repr、ascii 进行转换：
s = '{name!r}{name!a}{name!s}'.format(name='5')     输出：'5''5'5
s = '{name:$<10}'.format(name='aa')   指定宽度，'aa        '，字符串左对齐，数字右对齐，<,>,^分别表示左中右对齐，$为指定的填充字符，默认空格
s = '{num:10.2f}'.format(num=3)      同时指定宽度和小数位数
s = '{name:,}'.format(name=500000)  逗号为千位分隔符：500,000
s = '{name:#b}'.format(name=34)      #号，0b100010，会加上类型的前缀

s = '{name}'.foramt_map({'name': '张三'})         format_map()可以隐射字典
 
f'{name}'                                                                                        name是一个变量

bytes和bytesarray：
b'abc'， b'ca\xc3\xa9', \n, \r
都能使用字符串的方法: endswith、replace、strip、 upper等
my_bytes[1]        获取的是一个0-255的整数
my_bytes[0: 1]     得到的是一个长度为1的bytes对象

b = 'abc'.encode('utf-8', errors='replace')          # 编码: b'abc',  无法编码的字符替换成？问号
b'\xe9al'.decode('utf-8', errors='replace')          # 解码 ，无法解码则替换为问号：�al

utf-8, u8, U8, utf8, utf_8           # utf-8的几种表示方式

--------------------------------------------------------------------------------------

容器序列：
list，tuple，collections.deque   
存放的是它们包含的任意类型的对象的引用

扁平序列：
str、bytes、bytearray、memoryview、array.array
只能容纳一组类型，存放的是值。或者说是一段连续的内存空间

可变：
list，collections.deque 、bytearray、memoryview、array.array

不可变：
str、bytes、tuple

collections.deque      # 双端队列，反复做先进先出操作，效率比list高

集合set检查元素是否存在效率比较高，set为检查元素做过优化


数组array：
存放1000万个浮点数的话，array比列表效率高的多
支持跟列表一样的操作: pop, insert, extend, append，+，+=，frombytes, tofile，等。。。
只能存放单一类型
from array import array
arr = array('d'，[1,2,3,4,5])    # 类型码 'd' 代表有类型的字符，指定底层C语言应该存放什么数据类型
arr.tofile(file)                       #  放入文件
arr.fromfile(file, 1000)          # 将1000个从文件读出
arr[-1]                                 # 数组最后的元素


双端队列：
collections.deque类
是线程安全，可以快速从两端添加或删除元素
dq = collections.deque(range(10), maxlen=10)    # 队列多存放10个元素
实现了列表大部分操作：
+=
dq.append(e)
appendleft(e)
clear()
__copy__()                # copy.copy()的支持
count(e)
__delitem__(p)
extend(i)
extendleft(i)
__getitem__(p)
__iter__()
__len__()
pop()
popleft()
remove(e)
reverse()
__reversed__()
rotate(n)                    # 旋转n个元素，从一段放到另一端，n>0则右边n个数出队，然后从左边入队，反之亦然
__setitem__(p, e)         # s[p] = e
队满添加元素会挤掉另一边的元素


queue模块：
线程安全的队列，同步
Queue
LifoQueue
PriorityQueue
SimpleQueue
队满会被锁住，停止入队


multiprocessing模块：
Queue
oinableQueue


asyncio模块：
Queue
LifoQueue
PriorityQueue
JoinableQueue


heapq模块：
让用户把可变序列当作  堆队列  或  优先队列  使用


列表数据类型list：
索引、切片、拼接、相乘

索引：
正序：0 1 2 3...，逆序：-1 -2 -3...
取最后一个：l[-1], l[len(l)-1]        不减1会超出索引范围
l.append()                 追加
l.insert(位置，'值')     指定位置插入
l.pop(索引)                弹出，默认末尾
l.extend(列表)           合并两个列表，修改原列表，"+="就地修改。list1 = list1 + list2则返回新列表，效率比extend低    
l.clear()                     清空，l[:] = [ ]
l.count（'值'）          计算值出现次数，深层列表的值不计算
l.index（'值'）          第一次出现位置的索引
l.remove（'值'）       删除首个出现的值，无返回，找不到报异常
l.copy()                     潜拷贝，注意不是引用
del my_list[2]           删除索引为2的
l.reverse()                 反转
l.sort(reverse=True，key=func)       排序，  reverse=True降序，key排序的函数，不能同时有数字跟字符
l.sort(key=len)          参数key是一个函数，根据长度排序，len(3)报错，int不能使用len

列表比较：元素依次比较，数字跟字符串比较会报错，字符串按ASCII码比较
m = max(l，[key=lambad])              找出最大值，比较，数字跟字符不能比较，最小值min(), key可选
s = sum(l)                求和，列表内只能是数字

动态删除列表元素：
l = len(my_list)
i = 0
while i < l:
    if 'xx' in my_list[i]
        del my_list[i]
        l -= 1
        continue         # 跳过加1环节，删除元素会使列表向前移位
    i += 1 

切片：
[开始：结束：方向步长]           负数为逆向
l[1:3:2]       正向
l[-3:-1]       逆向
l[-1: :-2]     逆向
l[-5:]          从-5开始正向取，能取到-5，-4、.....-1
l[:len(l)]      全部，或l[:], 或l[:None]
l[:4], l[4:]    两个不重复的部分
my_list[start:stop:step]       会调用 my_list.__getitem__(slice(start, stop, setp))

l[3::2] = [11, 22]          # 切片赋值，不允许：l[2: 3] = 20  这种操作
l[2:3] = (44,)               # 返回还是列表

a = [1,3]
b = [1, 3, a] * 3          # 嵌套乘法，内部得到的是a的三个引用，等价于循环 l.append(a) 三次

a = 'hello'
a[a.find("llo"): a.find('llo')+len('llo')]         切片取出子串 'llo'

a = [1,2,3,4,5,6,7]
a[:3:-1]                 结果[7, 6, 5]
a[3:-5:-1]              结果[4]

l[len(l)] = '值'             会报错，超出范围的列表赋值索引
list('ab')                      ['a', 'b']
list(10)                        报错，整型不能迭代
int（[1,2]）                 报错
int（*[1]）                  解包

列表支持的符号：+、*、in、
[1,2] * 2 = [1,2,1,2]
[1,2] + ['a'] = [1,2, 'a']

切片赋值：
l = list('aaaa')
l[1:1] = [2, 3, 4]     l==> [a, 2, 3,4,a,a,a] 相当于插入操作

l.append(l.pop(0))   将第一个元素放到末尾  

reversed()   返回一个反向迭代序列，不是列表，不能用切片

sorted和list.sort()背后的算法是Timsort，一种自适应算法，根据原始数据的顺序
特点交替使用插入排序和归并排序。以达到最佳效率。

-----------------------------------------------------------------------------------
元组tuple：
不可变，存放值对应的地址，也就是指向的地址不变，值可能修改（可变类型），
如元组里面的元素是一个列表，则只能修改列表里的值，不能修改列表本身
t.index("值")     # 返回第一个匹配的值的索引
t.count("值")    # 计数，值出现的次数

可以：切片（返回元组）、max、min、sum、len，in、*、+、is、>、<、=、、!=、sorted（元组）会返回一个排序的列表
(1，2）* 2 == （1，2，1，2）
s, y = (1, 2)              拆包
s, *b = (1, 2, 3, 4)    拆包，b是一个列表。列表、字符串都能拆包
x, *y = 9,                 拆包，y是一个空列表
print(*(1,2,3))          拆包

t = (2)              # 是int类型，只有一个元素的时候要加逗号","

2*(4+2,)  ==> (6, 6)

------------------------------------------------------------------------------------------
字典类型dict:
底层基于散列表
可散列对象：调用hash()函数不报错
key=value，key不可变，不重复

len(d)                                        项的个数
in、not in                                  成员运算，针对key
'xxx' in d                                   xxx是否在d的key中
d = dict.fromkeys(列表，值)       初始化字典，列表的元素作为key，value为值。或{}.fromkeys(列表，'x')         
d = dict([(1,2)])                          符合这种格式的能转成字典
d['age'] = 18                             增加，d.__getitem__('age')
del d['xxx']                                删除

d.pop('key'，y可选)            # 返回删除的key的值，无则返回y，没有y会报错
d.popitem()                       # 元组方式返回随机删除的键值对，一般从末尾删除
d.keys()                            # 类型dict_keys，python2是列表
d.values()                         # 类型dict_values
d.items()                          # 列表包含元组，类型dict_items
d.update({1: 2, 3: 4})         # 更新，有则覆盖，无则添加
d.clear()                                  # 清空
d.get('xxx'，默认值)                 # 获取            
d.setdefault('key', 默认值)        # 返回字典中key对应的值，key不存在则添加，值默认None，类似get
d = d.copy()                            #  浅拷贝

内置模块的字典，实现的方法跟dict差不多
collections.defaultdict
collections.OrderedDict

字典里的键值对都是引用，存入时先做hash()运算

每次启动python解释器都会生成一个随机盐值，是为了防止DOS攻击而采取的一种安全措施，
str、bytes、datetime对象的散列值计算过程会多了随机加盐这一步，盐值是python进程内的
一个常量

如果有一个整型对象，而且它能被存进一个机器字中，那么它的散列值就是它本身。hash(1)==1

dic[key]背后散列表算法：
python首先调用hash(key)计算key的散列值，把这个值的低几位数字当作偏移量，在散列表里查找
表元(一个键值对为一个表元)，具体取几位，需要看散列表的大小，若找到表元为空，则抛出KeyError
异常，否则，表元里会有一对found_key: found_value，这时候校验key == found_key是否为真
，相等则返回found_value。
不相等的情况称为散列冲突，算法会在散列值中再另取几位，用特殊方法处理一下，把得到的的数字再
当作索引来寻找元素，然后重复上面步骤。

字典更新跟添加新值跟上面基本一样

1、字典键必须是可散列的。支持hash()函数，支持通过__eq__方法检测相等性，若a == b, 则hash(a) == hash(b) 也为真。
2、字典在内存上开销巨大。字典使用散列表，散列表是稀疏数组(总有空白元素的数组)
3、键查询很快
4、键的次序取决于添加的顺序
5、往字典里添加新键可能会改变已有键的顺序。添加键，解释器可能做出为字典扩容的决定：新建一个更大的散列表，把字典已有的
     元素添加到新表里。过程可能发生散列冲突导致键的次序变化。一边迭代字典一边修改字典，循环可能跳过一些键，甚至是跳过字
     典中已有的键。

--------------------------------------------------------------------------------------------------------
集合set：
背后是散列表
集合中的对象必须是可散列的
set本身不可散列，但frozenset（不可变集合）可以

方法：
s1.discard('xx')         删除元素
s1.remove('xxx')       删除元素，不存在会报错
s1.clear()                  清空
s1.pop()                   删除，返回值，没有则报错，一般删除第一个元素
s1.update({1,2,3})     更新，无则添加
s1.copy()                   浅拷贝

s1.add('xxx')            添加，一次添加一个，update一次可以添加多个
s.add(元组)              元组是不可变类型，可以添加

支持的符号：len、in、not in、set1 == set2   判等或不等!=，不支持加"+"号
__ior__
__iand__             交集，s &= z
__ixor__              并集，s |= z,  s.update(it, ..)
__isub__             差集， s -= z， s.difference_update(it, ...)
__le__                 <=, s.issubset(z), 是否为z的子集
__lt__                  <
__gt__                 >
__ge__                >=
__eq__
__ne__
__and__              交集，s & b
__or__                 并集，s | b,  s.union(it, ...)
__sub__               差集，s - b
__xor__               对称差集，s ^ b，s.symmetric_difference(it)
__contains__       in 操作
__iter__               返回迭代器
__len__
s.isdisjoint(z)          是否不相交

for i in enumerate(集合):                枚举（索引，值），元组(0,1)（1，2） 
    print(l)  

交集
集合内元素：不可变类型，无序，不重复
空集合s = set()  ，s={1}集合， s = {}是空字典
类型转换：s = set('hellooo') == {'h', 'e', 'l', 'o'}，转换的类型里不能有可变类型，如列表嵌套列表
转换字典只是得到字典的key

内置方法(关系运算)：
交集：set1 & set2             # set1.intersection(set2)
并集：set1 | set2               # set1.union(set2)
差集：set1 - set2               # set1.difference(set2), 有先后顺序，得到set1在set2中没有的
对称差集：set1 ^ set2       # set1.symmetric_difference(set2), 并集中去掉交集部分

父子集，包含关系：
a包含b, 比较a大于b，a有b的全部元素，还有不是b的元素
s1.issuperset(s2)    判断s1是s2的父集，返回布尔值
s1.issubset(s2)       判断s1是s2的子集
去重后无序
s1.isdisjoint({1,2,3})    判断，没有共同部分返回true

fset = frozenset({1,3})            不可变集合
fset = frozenset(range(10))

s = {1，2，3} 效率比 s = set([1,2,3])这样创建效率要高，前者利用一个专门的叫做BUILD_SET的字节码来创建集合

set、frozenseet跟字典一样，背后也是散列表，存放元素的引用
1、集合里的元素必须是可散列的
2、集合很消耗内存
3、可以很高效的判断元素是否存在某个集合
4、元素次序取决于添加顺序
5、添加元素，可能会改变集合里已有元素的次序
---------------------------------------------------------------------------------------------

可变和不可变：
可变：dict，list，set                                                地址不变，里面内容改变
不可变：int，str，tuple，float，frozenset                 内容改变，地址必须改变

类型转换：
str   转     int，list，set，tuple
----------------------------------------------------------------------------------------------

短路运算：
a = 0 or 1         返回1
a = 0 and 1      返回0

断言：
调试程序时使用
assert a==1, '错误信息'            # a不等于1则呈现报错，后面是错误信息
File "C:/Users/gg/PycharmProjects/lianxi/lianxi.py", line 8, in <module>
    assert a==1, '错误信息'
AssertionError: 错误信息


文件操作：
模式：
r         默认读文本"rt"，读二进制"rb"(图片)，找不到文件报错
w        写，从头覆盖原有内容，找不到文件则创建，"wb"写入二进制(图片)
x         创建并以写方式打开, 文件已存在则报错
a         追加，文件不存在则创建文件进行写入
b         二进制 
t         默认，文本模式
+        r+：不覆盖读写、w+：覆盖读写、a+都是以读写方式打开文件，这种使指针来回移动，效率不高
U

f = open(file, mode='r', encode='utf8')              打开文件，返回一个流
读：
content = f.read(3)                       读取三个字符或字节(二进制）, 默认读全部
f.readable()                                  判断是否可读取
f.readline(3)                                  读取一行中的3个字符或字节，默认读取一行
f.readlines()                                  读取多行，返回一个列表
f.seek()
f.seekable()
f.name                                          返回打开的文件名

写：
count = f.write('xxx')                 返回3，返回写入的字符或字节（二进制）数，默认没有换行
f.writelines(['xxx\n', 'yyy'])         迭代写入，需要手动写入'\n'换行

f.close()                                                                关闭文件

with open(file, mode='r', encode='utf8') as f:     打开文件方式二，上下文管理器，自动释放资源
    with open(file, 'r') as f2:

文件复制原理：读取一个文件内容到缓存，再写入到另一个文件

文件修改两种方式：
1、打开全部读入内存修改，再以w模式打开，将内存中的内容写入文件，速度快，不适合大文件
2、打开两个文件，读入一行写入一行，最后使用os.remove(文件路径)删除旧文件，然后修改新文件名，占内存小

f.seek(offset)   移动文件指针位置
w = f.tell()       返回文件指针位置

读取大文件：
使用readline，每次读取一行，当读到末尾就退出
f = open ('信息.txt')
while True:
    t = f.readline()
    if not t:
        break
    print(t)
f.close()

import sys
for line in sys.stdin:
    print(line)                      # 迭代标准输入的行

l = list(open('a.tt'))           # 等价于readlines

with open('a.tt') as f:
    a, b, c = f                    # 解包，左边跟右边行需要相同，否则报错

f=open('a.tt', 'w')
print('日志', file=log)          # 将print结果写入文件，默认自带换行符‘\n’

----------------------------------------------------------------------------------------
os模块：
操作系统接口模块
import os
os.path.dirname(__file__)   当前文件目录路径，绝对路径，str类型
os.getcwd()                        同上
os.path.join(os.path.dirname(__file__), '图片'，'图片2'，'aa.jpg')      路径拼接，可以多个
os.path.isabs('xxx/xx/x.jpg')                                    判断是否是绝对路径
os.path.abspath('a.txt')                                           获取文件的绝对路径，传入__file__当前文件绝对路径
os.path.split('xx/xx/aa.jpg')                                     将文件路径和文件名切割，('xx/xx', 'aa.jpg')
os.path.splitext('xx/xx/aa.jpg')                                将文件路径和扩展名切割，('xx/xx/aa', ".jpg")
os.path.getsize('xx/xx/aa.jpg')                                返回文件大小，单位：字节
os.path.isfile()          是否是文件
os.path.isdir()           是否是路径

os.listdir(目录)                      返回目录下的所有文件夹或文件的名字，列表
os.mkdir(目录)                      在目录下创建文件夹
os.rmdir(目录)                      删除目录下的文件夹，只能删除空目录
os.path.exists(r'c:')                判断是否是一个目录
os.removedirs(目录)             只能删除空目录
os.remove('xx/aa.txt')           删除文件
os.chdir(r'd:')                       切换目录到D:\\盘

os.system('/usr/bin/a.py')         # 执行a.py
os.startfile('C:\aa.exe')              # windows特有，执行aa.exe

删除非空文件夹：
flist = os.listdir(目录)        列出文件夹下的所有文件，然后删除所有文件，再删除空目录
for f in flist:
    path1 = os.path.join(目录，文件名)        拼接文件
    os.path.remove(path1)                          删除文件
else:
    os.rmdir(目录)                                       删除空文件夹


import webbrowser
webbrowser.open('http://www.baidu.com')    # 这个模块可以打开浏览器指定网址


heapq堆模块


from collections import deque                # deque双端队列


sys模块：
python自身的运行环境
import sys
sys.path               模块搜索路径，先从当前项目下，最后到第三方包site-packages
sys.version           python版本
sys.argv               一个列表，终端运行python xxx.py aa bb，将后面的参数放入这个列表  
sys.path.append('xxx/xx/x')   告诉解释器还可以去哪里找模块


import importlib
import test
print('-----------')
test = importlib.reload(test)    # 重新导入一次test模块，替换原来的


time模块：
import time
time.asctime(元组)                将当前时间转换为str类型：'Mon Jan 24 21:03:51 2022'
t = time.time()                      时间戳
time.sleep(3)                         睡眠3秒
time.strftime('%Y-%m-%d %H:%M:%S')        输出格式转换：'2021-06-15 17:08:53'
time.ctime(t)                        时间戳转换成日期：'Tue Jun 15 17:01:48 2021'
a = time.localtime(元组)       时间戳转为元组形式：time.struct_time(tm_year=2021, tm_mon=6, tm_mday=15, 
                                        tm_hour=17, tm_min=1, tm_sec=13, tm_wday=1, tm_yday=166, tm_isdst=0)
time.mktime(a)               元组转成时间戳, 秒形式
time.strptime('2020/11/23', '%Y/%m/%d')    转换成元组：time.struct_time(tm_year=2020, tm_mon=11, 
                                                                        tm_mday=23, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, 
                                                                        tm_yday=328, tm_isdst=-1)
from time import perf_counter as pc
t = pc()
print('a')
a = pc()-t
print(a)                   # 精度较高的计时器

timeit模块：
测量代码执行时间


memory_profiler模块:
内存分析，在需要内存分析的代码之前用@profile进行装饰，再命令行: python -m memory_profiler xxx.py
输出：行号、 内存使用情况、  内存增长情况、  Occurrences、  对应的内容

objgraph模块:
统计、定位和过滤对象、遍历和显示对象图

trace模块：
代码覆盖率分析


fileinput模块：
可以同时迭代多个文件或流的内容行


datetime模块：
import datetime
datetime.date.today()             返回今天日期
datetime.datetime.now()        返回现在日期时间
datetime.timedelta(week=3)  返回3周后，可以加减的时间         

random模块：
import random
random.random()                   [0-1)之间小数
random.randrange(1, 10, 2)    1到10之间整数，步长2
random.randint(1,5)                范围内的整数
random.choice('xx')                 随机选取
random.shuffle(列表)               打乱列表顺序，返回None一般表示就地修改列表
random.sample([1,1,2,3,4], 5)    从序列随机选5个值，几个值各不相同

随机验证码：
code = ''
for i in range(4):
    r1 = str(random.randint(0, 9))                 数字
    r2 = chr(random.randint(65, 90))            大写字母，chr函数将数字转为字符
    r3 = chr(random.randint(97, 122))          小写字母

    code += random.choice([r1, r2, r3])


hashlib模块：
哈希加密，不可逆
m5 = hashlib.md5('xxxxx'.encode('utf-8'))           md5加密，字符串要先编码
m5.hexdigest()                                                   查看加密结果，32位
sha1                 40位
sha224             56位
sha256             64位
sha512             128位


re模块：
正则表达式
import re
r = re.match(r'^xx$'， '字符串')      从开头开始匹配，没有返回None
r = re.search('^xx$'， '字符串')      匹配整个字符串，匹配到第一个返回，建议开头结尾^$
r = re.findall('^xx$'， '字符串')       匹配全部，找到全部, 返回列表
r = re.finditer('^xx$'， '字符串')      跟findall一样，不过返回迭代器
r = re.sub(正则, '新内容'，'str')        替换
r = re.split(正则，字符串)                根据正则匹配到的切割，返回列表
com = re.compile(正则)                  创建模式对象，提高匹配效率。com.search(字符串)
escape('www.baidu.com')               www\\.baidu\\.com  对字符串中的正则表达式特殊字符都进行转义

r.group([group1, ...])                     提取匹配到的内容, 除0外，还有最多99个编组
r.start([group])                             起始索引
r.end([group])                              结束索引+1
r.span([group])                            开始跟结束索引

贪婪匹配：尽可能多的匹配字符

"." 匹配除换行符（\n）之外的所有字符
"^"  开头
"$"  结尾
"*" 匹配前面0次或多次
"?" 匹配前面0次或1次
"+" 匹配前面1次或多次
{m, n}  匹配前面的m次到n次，{m, }m次到多次
[a-z0-9]    匹配其中一个，范围
[^a-z]       取反
\s             空白，大写相反，下同
\d             数字
\b            边界
\w           [a-z0-9A-Z]
"|"           或
()             分组，r.group(1)提取第一组

re.match(rb'\d+', b'\xd2\ffd3')             # rb匹配字节序列


pillow模块    处理图片
----------------------------------------------------------------------------------------------------
函数：
申请内存空间保存函数体代码，内存地址绑定函数名，定义会检测语法

func(1, 3) * 10        # 函数的返回值乘10
func(func(1, 2), 3)   # 函数当参数

关键字参数：key=value，位置参数放在关键字参数前面，不能重复传参数
默认参数在函数定义阶段赋值：def func(a=3)  ，列表做参数会改变
默认参数不应该使用可变类型，如列表
可变长参数：*与**，*args是元组格式、**kwargs字典格式，*args放在**kwargs前面
解包：*[1,2,3]<==>1 2 3  ，*'hello'<==>h e l l o，单个*号解包字典只获得key，*{1：2，3：4}  <==>1 2
def fun(a,b,*,x,y)  # *后面的参数为命名关键字参数，传值k-v：x=1,y=2
fun(**字典)           解包字典，传给形参**kwargs再封包

高阶函数：接受函数作为参数，或者把函数作为返回结果的函数是高阶函数。如map、filter、reduce

解包，拆包：
x, *y，z = 1, 2, 3            任何可迭代对象, y始终是一个列表：[ 2 ]

lambda匿名函数：
lambda 参数：返回值
精简，用在临时使用一次的场景
方式一：fun = lambda x, y：x + y          或者 lambda *args：print（args）,不能使用**kwargs
fun(1, 2)
返回：3

方式二：res = (lambda x:x+1)(2)   相当于立即执行函数
方式三：[lambda x: x+1 for i in range(10)]

函数注解：
def fun(name:str, age:int)->int:        
    pass

提示参数类型，参数有默认值，注解放在参数和等号=之间
def fun(s:str, text:'int > 0'=20) -> str:              
    pass
------------------------------------------------------
def func():
    print(x)
x = 1
func()
输出：1
以函数定义阶段为准

x = 111
def func()
    print(x)
    x = 222
func()
报错，在定义前使用x，作用域
----------------------------------------------------------------------------------------------------
global：全局作用域，用在改变不同作用域的不可变类型
nonlocal：非局部作用域的修改，不是本地，在当前层的外一层开始，修改闭包的外部函数的值
----------------------------------------------------------------------------------------------------
闭包：
特点：拥有函数功能，还有函数数据，一个函数里面嵌套另一个函数，内部函数使用到外层函数
的变量，并且返回值是内部函数（不调用）

有点像类

缺点：
作用域没那么直观，变量不会被垃圾回收，所以有一定的内存占用问题

作用：
可以使用同级作用域，读取其它函数内部变量，延长作用域

总结：
闭包看似优化了变量，原来需要类对象完成的工作，闭包也可以完成
由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存
闭包的好处是使代码变得简洁，便于阅读
闭包的理解是装饰器的基础

def fun(a):
    c = 10
    def fun2(b):
        print(a+b+c)
    return fun2

my_fun = fun(1)               my_fun得到fun的返回值fun2的函数引用
my_fun(2)                         执行fun2函数
输出：13

my_fun.__code__.co_freevars  ==> ('a', 'c' )         # 存储外层变量a, c的地方
my_fun.__closure__[0].cell_contents                     # 存储a的值的地方，索引1是c的值

闭包是一种函数，他会保留定义函数时存在的自由变量的绑定，调用函数时，虽然定义的作用域
不可用了，但是依然可以使用那些绑定。

nonlocal的作用是把变量标记为自由变量，nonlocal a, c
-------------------------------------------------------------------

装饰器(decorate)：
不改变原代码，改变原函数的指向，还是原来的调用方式，在它执行的前后加功能
在闭包基础上，传入函数作为参数

特性：
1、能把被装饰的函数替换成其它函数
2、装饰器在加载模块时立即执行

先执行装饰器，再执行被装饰的函数

@decorate            等价于：func = decorate(func)
def func():
    pass


通用装饰器：有返回值，有不定参数：
import functools

def f1(func):                                   # 参数是一个函数对象
    print('先执行这一行')
    @functools.wraps(func)            # 这一句可以将__doc__的内容跟__name__还是原来被装饰函数的内容 
    def wrapper(*args, **kwargs):   # 跟被装饰的函数参数跟返回值要一样，封包
         ....
         res = func(*args, **kwargs)  # 这里将*args、**kwargs拆包
         .....
         return res
    return wrapper

@f1          #  指向改变，test = f1(test) <==> wrapper， f1的返回值是一个函数引用，"@f1"叫语法糖，因为更简洁了
test()

其它两个装饰器：
functools.lru_cache(maxsize, True)
functools.singledispatch

多个装饰器先装下层的，调用则先最外层一层一层下去：
应用顺序与列出顺序相反
加载顺序：自下而上
执行顺序：自上而下

@f1            # 3、fun = f1(fun = f2(fun))
@f2            # 2、fun = f2(fun)
def fun()     # 1、先执行@f2
    pass

等价于：
fun = f1(f2(fun))


带参数装饰器：
最外层作为函数调用，返回一个装饰器
def s(num)
    def f1(func):
        def wrapper(*args, **kwargs):
             ......
             res = func(*args, **kwargs)
             print(num)  # 使用带参数装饰器的参数
             ......
             return res
        return wrapper
    return f1

@s(num=100)          # 调用函数s()，返回一个装饰器用来装饰函数test()
test()

类装饰器:
@MyClass
test()
或
@MyClass.静态方法
test()

装饰器与设计模式中装饰器模式不是同一个
------------------------------------------------------------------

异常：
try:
    可能发生异常的代码
except Exception：
    print(Exception)
except 异常类型 as 别名：
    print(别名)
except(TypeError, ValueError, ZeroDivisionError) as e:     # 同时包含多种
    print(e)    
except：     # 不添加任何异常类，将捕获所有异常
    pass
else：
    没有捕获到异常时执行这里
finally:
    最后执行这里


try结合return使用：
def fun():
    try:
        return 11
    except:
        return 22
    else:               # else要放在finally前面才不会有语法错误
        pass           
    finally:
        ....
        return 33   # 这里有return，则try跟except里面的return不会执行，
                             没有return，则执行这里的语句后，才执行上面try或except里面的return

while True：
    try:
        pass
    except:
       pass
    else:
        break    # 循环，直到没有捕获到错误

主动抛出异常，raise语句：
raise Exception('这是异常信息')
try:
    raise Exception('异常')
except:
    print('捕获异常')
    raise ValueError from None         # raise ... from ...    提供自己的异常上下文

一些内置异常类：
Exception
AttributeError
OSError
IndexError
KeyError
NameError
SyntaxError
TypeError
ValueError
ZeroDivisionError

自定义异常类：
需要直接或间接继承Exception类
class MyException(Exception):
    pass

异常从函数向外传递到调用函数的地方

from warnings import warn    # 可以发出警告的模块
warn('aaaa')      # 发出警告                      

-----------------------------------------------------------------------------------

python包：
__init__.py文件：
导入包的时候会默认执行__init__.py文件里的东西

import  包          # 这样导入，__init__.py里面的内容将是包的内容。包.xxx

from 模块 import *：可以使用模块里面的所有内容，如果没有定义__all__ = []
from 包 import *：   该包中的内容(模块)是不能访问的，需要在__all__ = []定义可以访问的模块，一般
                               在包的__init__.py中定义__all__ = []暴露

在模块中使用__all__ = ['通过* 可以访问的模块']，可以限制在使用from aa import *导入的内容就是__all__里的内容

python动态导入模块方式：ss = __import__("模块名")

if __name__ == '__main__'
在当前模块打印__nam__的值是__main__
在其它模块导入执行时__name__的值是模块名

绝对导入：从包开始
相对导入：从当前位置开始，不能超出包的位置

大型项目中，模块之间相互导入，出现循环导入问题
避免方法：
1、重新架构
2、将导入语句放在其它地方，比如函数里面（推荐）
3、把导入语句放到最后

print(__file__)  # 当前文件的绝对路径

模块.__file__     # 模块的绝对路径

----------------------------------------------------------------------------------

r'\'不能单独出现,或在末尾出现
if 1：a += 2         可以这样写，后面只能一条语句

格式化输出：print(f'xxxxx{name}各家各户')

LEGB：
L：local 本地 局部变量
E：encloseing 嵌套
G：global 全局
B：built-in 内置的


-----------------------------------------------------------------------------------
DB API是一套连接数据库规范，python跟数据库的连接规范，python数据库模块规范，如pymysql模块

全局变量：
apilevel                    使用的python DB API版本
threadsafety             模块的线程安全程度如何
paramstyle               在SQL查询中使用哪种参数风格

pytho DB API指定的异常：
StandardError                        所有异常超类
Warning                                发生非致命问题时引发
Error                                     所有错误条件的超类
InterfaceError                        与接口（不是数据库）相关的错误
DatebaseError                       与数据库相关的错误的超类
DateError                              与数据相关的问题，如值不在合法范围内
OperatinalError                     数据库操作内部错误
IntegrityError                        关系完整性遭到破坏，如键未通过检查
InternalError                         数据库内部的错误，如游标无效
ProgrammingError                用户编程错误，如未找到数据库表
NotSupportedError               请求不支持的功能，如回滚

连接和游标：
connect的常用参数
dsn                       数据源名称，具体含义随数据库而异，必选
user                      用户名
password              密码
host                      主机名
dadabase              数据库名

连接对象的方法
close()                 关闭，关闭连接对象，之后连接对象及其游标将不可用
commit()             提交，提交未提交的事务，如果支持的话，否则什么都不做
rollback()             回滚，回滚提交的事务
cursor()                返回连接的游标对象

游标对象的方法
callproc(name[, params])         使用指定的参数调用指定的数据库过程
close()                                    关闭游标
execute(oper[, params])           执行一个SQL操作，可指定参数 
executemany(oper, pseq)        执行指定的sql操作多次，每次都序列中的一组参数
fetchone()                              以序列的方式取回查询结果中的下一行，如果没有更多的行，返回None
fetchall()                                以序列的方式取回余下所有行
nextset()                                跳到下一个结果集，这个方法可选
setinputsizes(sizes)                 用于为参数预定义内存区域
setoutputsize(size[, col])         为取回大量数据而设置缓存区长度

游标对象的属性
description                由结果列描述组成的序列（只读）
rowcount                   结果包含的行数（只读）
arraysize                    fetchmany返回的行数，默认为1

类型：
Date(year, month, day)                  创建包含日期值的对象
Time(hour, minute, second)           创建包含时间值的对象
Timestamp(y, mon, d, h, min, s)     创建包含时间戳的对象
DateFromTicks(ticks)                     根据从新纪元开始过去的秒数创建包含日期值的对象
TimeFromTicks(ticks)                     根据从新纪元开始过去的秒数创建包含时间值的对象
imestampFromTicks(ticks)             根据从新纪元开始过去的秒数创建包含时间戳的对象          
Binary(string)                                创建包含二进制字符串的对象             
STRING                                         描述基于字符串的列（如CHAR）
BINARY                                         描述二进制列（如LONG或RAW）
MUMBER                                      描述数字列
DATETIME                                    描述日期/时间列
ROWSID                                       描述行ID列

模块：
pymysql           连接mysql
sqlite3              连接SQLite
importlib          动态导入模块：importlib.import_module('datetime')    只能到py文件名

-------------------------------------------------------------------------------
网络编程：
socket模块
urllib跟urllib2模块         ret = urllib.request.urlopen("http://www.baidu.com")

标准库中一些与网络相关的模块：
asynchat            包含补充asyncore的功能
asyncore            异步套接字处理程序
cgi                     基本CGI支持
Cookie               Cookie对象操作，主页用于服务器
cookielib            客户端Cookie支持
email                 电子邮件支持（包括MIME）
ftplib                 FTP客户端模块
gopherlib          Gopher客户端模块
httplib               HTTP客户端模块
imaplib              IMAP4客户端模块
mailbox             读取多种邮箱格式
mailcap             通过mailcap文件访问MIME配置
mhlib                访问MH邮箱
nntplib              NNTP客户端模块
poplib               POP客户端模块
robotparser       解析web服务器robot文件
SimpleXMLRPCServer      一个简单的XML-RPC服务器
smtpd               SMTP服务器模块
smtplib             SMTP客户端模块
telnetlib            Telnet客户端模块  
urlparse            用于解读URL
xmlrpclib          XML-RPC客户端支持

SocketServer模块：
标准库提供的服务器框架基石，包括BaseHTTPServer、SimpleHTTPServer、CGIHTTPServer、
SimpleXMLRPCServer、和DocXMLRPCServer等服务器
四个基本服务器：TCPServer、UDPServer、UnixStreamServer、UnixDatagramServer

import socketserver

select模块：
select和poll函数实现异步I/O，windows不支持poll函数

Tidy模块，修复html的工具
XHTML解析模块
beautifulsoup4模块，解析html

启动一个简易web服务器，在浏览器输入http://127.0.0.1:8000/，提供所在目录的文件
# python -m http.server --cgi  

python web框架：
Flask
Django
TurboGears
web2py
Grok
Zope2
Pyramid

测试驱动开发：
unittest模块，通用测试模块，基于java测试框架JUnit
doctest模块，为检查文档而设计
标准库测试模块：pytest、nose

单元测试让代码管用
源代码检查让程序更好
性能分析让程序更快

PyChecker和PyLint：
检查源代码模块
# pychecker my.py          从命令行运行检查文件
# pylint module               检查模块或包

性能分析模块：
import profile, cProfile          #  标准库，后一个是c语言实现的(推荐)
profile.run("fun(3, 4)")
cProfile.run('range(10)'，'a.txt')   # 第二个参数将结果放到一个文件

ncalls         函数被调用次数
tottime      函数总计运行时间，不含调用的函数运行时间
percall       函数运行一次的平均时间，等于tottime/ncalls
cumtime    函数总计运行时间，含调用的函数运行时间
percall       函数运行一次的平均时间，等于cumtime/ncalls
filename:lineno(function)   函数所在的文件名、函数的行号、函数名

按函数的占用时间排序：
 import cProfile, pstats
    cProfile.run('test.run()', 'a.txt')     # 性能分析， 结果写入文件
    p = pstats.Stats('a.txt')
    p.sort_stats('time').print_stats()

------------------------------------------------------------------------------
扩展python：
JPython，IronPython(C#)
JPython可以轻松导入java的已经编译的类，或使用标准库
PyPy
Cython
weave
ctypes
NumPy
subprocess
PyCXX
SIP
Boost.Python

C语言扩展python

SWIG工具，主要用途是让你能够在python中使用既有的C语言代码

gc模块可以访问python垃圾收集器

-------------------------------------------------------------
程序打包：
Setuptools

setup.py    固定文件名
from setuptools import setup

setup(name='hello', version='1.0')     hello.py文件与版本


配置的级别：
后面的覆盖前面的
1、配置文件
2、环境变量
3、在命令行中向程序传递的开关和参数

logging模块：
记录日志
import logging

# 配置
logging.basicConfig(
    level=logging.DEBUG,       # 级别
    filename='log.txt',             # 写入的文件
    filemode='a',                      # 默认追加方式
    format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'  # 格式
)

logging.info('info')   # 记录info级别信息，下同
try:
    logging.debug('debug')
    1/0
except Exception as e:
    logging.error('error')
    logging.critical('严重%s' % e)

输出：
2022-08-17 21:55:26,394 test.py[line:64] INFO info
2022-08-17 21:55:26,394 test.py[line:66] DEBUG debug
2022-08-17 21:55:26,394 test.py[line:69] ERROR error
2022-08-17 21:55:26,394 test.py[line:71] CRITICAL 严重division by zero


pygame模块：
游戏






