安装：pip install -r requirements.txt
导出：pip freeze > requirements.txt

python的传递都是内存地址或引用传递

select、poll、epoll：
监管
IO多路复用，轮询

异步IO模型：
效率最高的，速度快
模块：asyncio  # 单线程实现并发
异步框架：sanic、 tronado、 twisted

同步与异步：
任务的提交方式

阻塞与非阻塞：
程序的运行状态

OSI七层:
应、表、会、传、网、数、物

四层：
应
传
网际层
网络接口层
*******************************************
五层：
应                  http/s、ftp
传                  tcp、ip                   段
网络层           IP协议                     包
数                  以太网协议              帧
物

包：头head+数据data，一层层加头：以太网头+ip头+tcp头+应用层头+应用层数据
ARP协议：将IP地址解析成mac地址
端口port：0~65535
IP+mac地址：唯一标识一台计算机，加端口号能唯一标识一台计算机的应用
路由协议

tcp三次握手：
1、请求                               SYN  seq=x
2、确认+请求                      ACK=x+1，SYN seq=y
3、确认                               ACK=y+1

A发送SYN为1请求连接，B收到返回SYN跟ACK都为1表示收到并请求连接，
       A返回ACK为1通知B双方以完成连接建立。有超时重传机制

SYN洪水攻击

tcp四次挥手：
1、fin
2、ack
3、fin
4、ack

对称释放方式，A发送FIN为1表示，B收到通知应用程序会话已结束，返回ACK为1
       应答，B发送FIN为1，A收到返回ACK为1的应答给B，A端time_wait两倍报文段寿命2MSL后关闭。

tcp拥塞控制：慢启动、拥塞避免、快速重传、快速恢复。流量控制：滑动窗口

tcp可靠，效率慢，udp不可靠，快，实时性较高时使用

DNS：
递归查询
迭代查询
**********************************************

用户画像：
就是用户的行为，搜索过哪些商品，看过什么等

http：
基于tcp
浏览器跟服务器传输

epoll：
轮询，事件通知，一个共享空间
nginx使用，linux使用

进程、线程、协程：
进程是资源分配的单位
线程是操作系统调度的单位
进程切换需要资源很大，效率很低
线程切换需要的资源一般，效率一般（在不考虑GIL的情况下）
协程切换任务资源很小，效率高
多进程、多线程根据cpu核数不一样可能是并行的，但协程是在一个线程中，所以是并发

进程池：
大量任务要执行时，创建一堆进程，形成进程池
优点：重复利用，减少创建和销毁的开销
使用：一般在测试时进行压力测试使用

开放封闭原则：
封闭:已实现的功能代码块
开放：对扩展开发

浏览器访问一个url过程：
域名解析
通过IP找到服务器建立tcp连接
返回响应
浏览器渲染
关闭tcp连接

垃圾回收机制(GC)：
变量名存地址
内存：变量存在栈区，值存在堆区
1、引用计数：值有零个变量引用就会回收，访问不到了，手动减少计数：del 变量名
2、标记清除：解决相互引用(循环引用)带来内存泄漏，引用计数一直不能为0
3、分代回收：给一个权重，高的会隔很长时间才扫描一遍，解决引用计数的每次全部扫描缺点，但不能及时回收垃圾

python进程是真正的并行

http协议：请求和应答

进程间通信：
1、管道：无名管道、命名管道、高级管道
2、消息队列
3、内存映射(共享内存)
4、socket(套接字)，可用于不同机器间的进程通信
5、信号量
6、信号

封装、继承、多态：python可以多继承

GIL锁跟Cpython解释器有关，跟python语言无关，Cpython使同一时刻只能有一个线程在cup执行（上锁）
只能是 并发，多核cpu使用多进程就是并行

互斥锁：逻辑上避免线程间死锁

深拷贝：全部数据拷贝过来。浅拷贝：拷贝最上层数据过来，再深层的是指向。
赋值操作只是指向，浅拷贝跟深拷贝一个元组则是指向，如果元组里面有列表，
则深拷贝就是深拷贝，浅拷贝还是指向。


服务器（nginx）----WSGI协议--------web应用（django）

面向切面编程：
只管一点点地方，其它已经做好了

python动态导入模块方式：ss = __import__("变量")

格式化输出：print(f'{name}')

python进程：
内存中申请内存空间，把代码丢进去运行，资源单位
****windows下创建进程会导入包含了目标函数的脚本文件，
要在if __name__ == '__main___'下面，才不会导致无限循环创建进程
linux下是重新拷贝一份代码运行，不会出现这种问题
创建进程：
from multiprocessing import Process
p = Process(fun, (a,))
p.start()    # 告诉操作系统创建进程
p.join()     # 主进程等待子进程执行结束才继续运行
p.terminate()  # 杀死当前进程
p.is_alive()  # 判断进程是否存活
p.daemo = True  # 设置为守护进程

自定义类然后继承自Process也可以创建进程
os.getpid()  # 查看当前进程的进程号
os.getppid()  # 父进程号

孤儿进程：子进程存活，父进程死亡
守护进程：守护着某个进程，跟随它死亡
互斥锁：使用前先加锁，牺牲效率，并发变成串行，保证安全
行锁：锁住一行
表锁：锁住一个表

线程：
执行单位
join()  # 主线程等待子线程结束才结束
同一个进程下多个线程数据共享
active_count()  # 统计当前正在活跃的线程数
守护线程：
t.daemon()
主线程等待所有非守护线程结束才结束

协程：
单线程下实现并发，在代码层面的切换，程序遇到IO后在代码层面切换，yield切换
gevent模块：
简写加分号
from gevent import monkey;monkey.patch_all()
from gevent import spawn

计算密集型用进程
IO密集型用线程，因为线程切换开销小，进程切换开销大
****一般多进程下面开多线程下面开协程

线程池、进程池：
避免无限制创建，跟销毁带来的开销
会降低效率，因为池满后只能排队

GIL：
Cpython，互斥锁，阻止同一进程下多个线程不能同时执行，无法利用多核优势
GIL锁跟Cpython解释器有关，跟python语言无关，Cpython使同一时刻只能有一
个**线程**在cup执行（上锁）只能是并发，多核cpu使用进程就是并行
进入IO，GIL会自动释放

递归锁：
所有人都可以加锁跟释放锁，里面会有个计数器，加锁+1，释放-1，但只能有一个人能执行

log日志：
五个级别，低---高
1、debug  详细信息
2、info   按预期运行
3、warning  警告
4、error  错误
5、critical  严重错误
一般是：年月日时分秒 哪个文件 第几行 日志级别 信息

元类：
在创建类的时候给它加功能，相当于装饰器最顶层，元类创建类，是类的类，元类创建元类
元类--->类--->实例对象

type就是一个元类，创建类：
myclass = type('MyClass', (元组要继承的类,), {'a':1, 'b':2, 'fun': 实例方法，静态方法...})
等价于：
class MyClass: 
    a=1
    b=2


globals()可以查看所有全局对象(函数、变量、类等)的引用，返回的是字典
a=1
def a():
    pass

a会覆盖，指向一个函数

ORM：
对象--关系，映射，django核心
数据库：类名对应表名，类属性对应字段
解决不用手写SQL

is：比较id、地址
==：比较值
-----------------------------------------------------------------

面向对象：
提升程序解耦合度，扩展性增强
缺点：设计复杂

私有，对外不对内，外界不能访问、子类也不能访问：
类定义的时变形才发生一次，之后定义的__开头的属性就是普通属性
私有属性：self.__age = 18
私有方法：def __fun(self)：
***双下划线，不是真正意义上的私有
访问：实例对象._类名.__属性名或方法

为何要私有：
外界会看到很多属性跟方法，会变得复杂
不想给外界直接使用，只能在内部开接口间接使用，可以在使用前附加逻辑

@property：
类实现的装饰器，将方法当成属性使用

使用方式：@property或老版本name = property(get_name(), set_name())
@name.deleter   # del obj.name
def name(self):

@name.setter    # obj.name = '张三'
def name(self):

调用父类方法：
super().父类方法     例：super().__init__()  # 参照属性最先发起者的mro顺序，新式类
父类名.方法(obj, name, age)  

继承的属性查找：
类名.__mro__()    查看父类的方法调用顺序，C3算法计算继承顺序，形成一个列表
先从当前对象找，然后到父类找，不是就近查找

菱形继承或钻石：
    A           爷爷类，不是object类
B       C      父类
    D           子类

非菱形：
A     B
C     D    E
       F
新式类：广度优先查找，一条分支一条分支找，最后才是object
经典类：深度优先查找

新式类：继承自Object，python3默认继承自object
经典类：不继承Object，python2

继承：
解决类与类之间的代码冗余问题，重用
python支持多继承
obj.__bases__查看继承的类

多继承：
优点：可以同时继承多个父类的方法跟属性，最大限度的重用代码
缺点：代码可读性变差，违背人的思维习惯，扩展性变差，引发菱形问题

多继承的正确打开方式--mixins机制：
尽可能提升多继承的可读性
是一种规范，在定义类时在后面添加MixIn，表示混入的一些东西、功能，提升可读性
例：
class UserMixIn：
    pass

多态：
前提：继承、重写父类方法
同一种事物多种形态，不同子类调用相同父类方法产生不同结果
方便使用者
一种编程思想

反射机制：
程序运行过程中可以动态获取对象的信息
obj是对象，类
setattr(obj, 'age')  # 设置对象属性
getattr(obj，'age', None)  # 获取对象属性值，不指定默认值会报错 
delattr(obj, 'age')  # 删除
hasattr(obj, 'age')  # 判断obj对象下是否有属性age，布尔值
例子：
getattr(obj, 'fun')()  # 获取obj对象的fun方法，并执行

linux：一切皆文件

类在内存中只有一份，实例对象有很多个
类属性：aaa = 'bbb'，使用：类名.类属性，实例对象.类属性（不推荐），向上查找
类方法：
@calssmethod
def 类方法名(cls):   # cls代表类，self代表实例对象
    cls.类属性    # 调用类属性
    cls.类方法    # 调用类方法
使用：类名.类方法

静态方法：
谁都能调用，不使用到实例属性跟类属性，使用静态方法
@staticmethod
def 静态方法():
    pass

调用：类名.静态方法

元类：
一切皆对象
父类不是元类
是类的类type，是
class Obj <=> Obj = type('Obj', (boject,), {...})
例子：
class mymeta(type):  # 继承了type，称为元类
    pass

class Obj(metaclass=mymeta):
    pass

实例化发生的事：
1、造一个空对象, __new__方法
2、执行__init__方法
3、返回初始化好的对象，__call__方法

类能向上找到元类
对象不能向上找到元类

----------------------------------------------------
类内置方法（魔法方法）：
双下划线开头和结尾
满足某种条件会自动调用
__str__（self）  # print打印对象会执行，返回字符串， return 'str方法'
__dict__
__del__  # 在del对象时会先执行，del obj或程序运行结束之前释放内存，可以自定义关闭文件
__new__  （cls，*args, **kwargs）# 创建一个空对象
__call__(self, *args, **kwargs)    # 使对象能加括号调用，例：obj = Obj(), obj()


------------------------------------------------------
python内置函数：
a = [1,2]
type(type(a)) == <class 'type'>

***map(func, 可迭代对象)   得到生成器对象
***filter(func, 可迭代对象)   过滤
***all（）                  全部为真返回True否则False
****dir（Foo）          查看有什么属性、方法
****divmod（10，3）计算商跟余数，返回（商，余数）
****isinstance（obj，Obj）类型判断，判断一个对象是否是一个类的实例，isinstance(2,int) True
****zip（[1,2], [3,4]）拉链函数，[(1,3), (2,4)]
****time = __import__('time')  导入time模块
abs（）绝对值
any（）有一个为真返回True
bin（）进制
oct（）进制
hex（）进制
bool（'1'）转换为布尔值
callable（函数，类...）判断是否可调用
chr（65） ASCII
ord（'A'）ASCII
enumerate（[1,2,3]）枚举下标跟值
eval（）执行字符串中的表达式
frozenset（{1，2，3}）不可变集合
hash（）得到哈希值
pow（10，2，3）平方，10的平方求余3
round（1.4）四舍五入，返回整数
slice（1，4，2）切片
sum（）


排序依据字典value：
res = sorted(dic, key=lambda k: dic[k])

-------------------------------------------------------
单例设计模式：
只有唯一 一个实例对象，无论实例化多少个对象，内存地址都是相同的，省内存
__new__方法，返回对象的引用
def __new__(cls, *args, **kwargs):
    obj = super().__new__(cls)   # 固定写法，返回super().__new__(cls)
    return obj

使用__new__实现单例模式：
class Obj():
    obj = None
    flag = False  # 定义一个标志，只执行一次初始化动作__init__

    def __new__(cls, *args, **kwargs):
        if cls.obj is None:
            cls.obj = super().__new__(cls)
        return cls.obj  # 每次实例化对象都返回第一次实例的对象的引用

    def __init__(self):
        if Obj.flag:
            return
        # 执行初始化动作
        ......
        # 将初始化标志置位True
        Obj.flag = True

async def：定义协程函数
垃圾回收机制：引用计数、标记清除、分代回收

转为二进制：bytes（'hello', encode='utf-8'）

python 三元表达式 ： a = 'b'  if  x>y  else  'c'
列表生成式：[  ]
字典生成式：  {}
集合生成式：  {}
没有元组生成式，因为元组不可变
其它生成式：
生成器表达式：
g = (i for i in range(10))
next(g) <==> 0

with open('aa.txt', 'r') as f:
    g = (i for i in f)  # 生成器方法读取文件，效率最高

迭代器：不依赖索引取值，基于上一次的结果继续，需要时创建一个值，节省内存空间，生成循环。
内置了__iter__方法的称为可迭代对象，__next__方法调用一次返回一个值，合起来成为迭代器对象
缺点：迭代器对象不能按索引取值，不能倒退，有生命周期，取完值就没了

生成器：一种迭代器，yield让代码挂起，下次从当前位置继续执行，yield后默认返回None
def func()
    print('********')
    x = yield 1
f = func()   # 调用函数得到一个生成器，函数体代码不会执行
f.__next__()  # 执行__next__()方法得到yield后面的值
f.send('一个值')   # 值给了x ，生成器刚开始不能传值，有next功能
f.close()  # 关闭后无法send()传值

for i in 可迭代对象，循环调用__iter__()得到迭代器对象，每次调用__next___()返回一个值给i

解包：
l = [1,2]
x, y = l

递归：
python递归默认是1000层，可以修改
两个阶段：
1、回溯：一层层调用下去
2、递推：满足某种条件，结束递归，一层层返回

数字类型int与float：
int(1.23) <=> 1
int('1.23') 会报错，不能之间将字符串小数之间转为整型
float('1') <=> 1.0
bin(10)  转二进制
oct（10） 转八进制 0o33
hex（10）转十六进制 0xd
复数：x = 10 + 3j

字符类型：
不可变类型，str(任何类型)
按索引取值，正取0，倒取-1，只能取不能赋值
切片[1:-1: 2]       反向步长[1:5: -1]得到为空  ，倒着走[5:1:-1]
长度len(s)
成员运算in 与 not in
s.strip('字符字符字符')                  去除左右两边字符，默认空格，可以多个，s.lstrip（''）左边空格、s.rstrip（''）右边空客
s.split('字符'，次数)                      切割成列表，默认空格分割，s.rsplit('xx')   从右边切割
大小写转换：s.lower（）转小写、s.upper（）转大写
判断开头结尾：startswith('xx')、endswih('xx')
''.join(列表)                                   拼接，列表里同时有字符串跟数字会报错，因为字符跟数字不能相加
s.replace('aa', 'bb', 次数)              aa替换为bb
s.isdigit()                                      判断字符串是否由纯数字组成，阿拉伯数字，isnumeric()能识别'4'、'四'、'IV'
s.find('值')                                    查找，返回索引
s.index('值')                                 返回索引
s.count('值')                                值出现的次数
s.isalpha（）                               是否是字母

--------------------------------------------------------------------------------------
列表list：
索引：
正序：1 2 3...，逆序：-1 -2 -3...
取最后一个：l[-1], l[len(l)-1]        不减1会超出索引范围
l.append()                 追加
l.insert(位置，'值')     指定位置插入
l.pop(索引)                弹出，默认末尾
l.extend(列表)           合并两个列表，或：list1 = list1 + list2    
l.clear()                     清空
l.count（'值'）          计算值出现次数
l.index（'值'）          第一次出现位置的索引
l.remove（'值'）       删除首个出现的值，无返回，找不到报异常
l.copy()                     复制
l.reverse()                 反转
del my_list[2]           删除索引为2的
l.sort(reverse=True，key=func)       排序，  reverse=True降序，key排序的函数，不能同时有数字跟字符

列表比较：元素依次比较，数字跟字符串比较会报错，字符串按ASCII码比较
m = max(l)              找出最大值，比较，数字跟字符不能比较，最小值min()
s = sum(l)                求和，列表内只能是数字
l = sorted（l）        排序，默认升序，reverse=True降序，数字跟字符不能比较         

动态删除列表元素：
l = len(my_list)
i = 0
while i < l:
    if 'xx' in my_list[i]
        del my_list[i]
        l -= 1
        continue         # 跳过加1环节，不会导致列表动态变化而发生漏删
    i += 1 

切片：
[开始：结束：方向步长]           负数为逆向
l[1:3:2]       正向
l[-3:-1]       逆向
l[-1: :-2]     逆向
l[-5:]          从-5开始正向取，能取到-5，-4、.....-1

a = 'hello'
a[a.find("llo"): a.find('llo')+len('llo')]         切片取出子串 'llo'

a = [1,2,3,4,5,6,7]
a[:3:-1]                 结果[7, 6, 5]
a[3:-5:-1]              结果[4]

l[len(l)] = '值'             会报错，超出范围的列表赋值索引
list('ab')                      ['a', 'b']
list(10)                        报错，整型不能迭代
int（[1,2]）                 报错
int（*[1]）                  解包

列表支持的符号：+、*、in、
[1,2] * 2 = [1,2,1,2]
[1,2] + ['a'] = [1,2, 'a']

-----------------------------------------------------------------------------------
元组tuple：
不可变，存放值对应的地址，也就是指向的地址不变，值可能修改（可变类型），
如元组里面的元素的一个列表，则只能修改列表里的值，不能修改列表本身
t.index("值")     # 返回第一个匹配的值的索引
t.count("值")    # 计数，值出现的次数

可以切片、max、min、sum、len，in、*、+、is、>、<、=、、!=、sorted（元组）会返回一个排序的列表
(1，2）* 2 == （1，2，1，2）
s, y = (1, 2)              拆包
s, *b = (1, 2, 3, 4)    拆包，b是一个列表，列表、字符串都能拆包
x, *y = 9,                 拆包，y是一个空列表
*y = （1，2，3）    装包
print(*(1,2,3))          拆包

t = (2)              # 是int类型，只有一个元素的时候要加逗号","

------------------------------------------------------------------------------------------
字典类型dict:
key=value，key不可变，不重复
len(d)  key的个数
成员运算：in、not in                  针对key
d = {}.fromkeys(列表，值)          初始化字典
d = dict.fromkeys(列表，值)       初始化字典，列表的元素作为key，value为值        
d = dict([(1,2)])                          符合这种格式的能转成字典
d['age'] = 18                             增加
'xxx' in d                                    xxx是否在d的key中
del d['xxx']                                删除

d.pop('key'，y可选)            # 返回删除的key的值，无则返回y，没有y会报错
d.popitem()                 # 元组方式返回随机删除的键值对，一般从末尾删除
d.keys()                       # 类型dict_keys，python2是列表
d.values()                    # 类型dict_values
d.items()                     # 列表包含元组，类型dict_items
d.update({1: 2, 3: 4})     更新，有则覆盖，无则添加
d.clear()
d.get('xxx')
d.setdefault('key', 默认值)       key不存在则添加，值默认None，存在返回字典中key对应的值，类似get

--------------------------------------------------------------------------------------------------------
集合set：
s1.discard('xx')         删除元素
s1.remove('xxx')      删除元素不存在会报错
s1.clear()                  清空
s = pop()                 删除，返回值，没有则报错，一般删除第一个元素
s1.update({1,2,3})    更新，无则添加
s1.add('xxx')            添加，一次添加一个，update一次可以添加多个
s.add(元组)              元组是不可变类型，可以添加

支持的符号：len、in，not in、
set1 == set2             判等或不等!=
不支持加"+"号
for i in lenumerate(集合):                枚举，元组(0,1)（1，2） 
    print(l)  

交集
集合内元素：不可变类型，无序，不重复
空集合s = set()  ，s={1}集合， s = {}是空字典
类型转换：s = set('hellooo') == {'h', 'e', 'l', 'o'}，转换的类型里不能有可变类型，如列表嵌套列表
转换字典只是得到字典的key
内置方法(关系运算)：
交集：s = set1 & set2      # set1.intersection(set2)
并集：set1 | set2               # set1.union(set2)
差集：set1 - set2               # set1.difference(set2), 有先后顺序，得到set1在set2中没有的
对称差集：set1 ^ set2       # set1.symmetric_difference(set2), 并集中去掉交集部分
父子集，包含关系：
a包含b, 比较a大于b，a有b的全部元素，还有不是b的元素
s1.issuperset(s2)   s1是s2的父集，返回布尔值
s1.issubset(s2)       s1是s2的子集
去重后无序
s1.isdisjoint({1,2,3})    判断，没有共同部分返回true

f = frozenset({1,3})    不可变集合

---------------------------------------------------------------------------------------------

可变和不可变：
可变：dict，list，set                                                地址不变，里面内容改变
不可变：int，str，tuple，float，frozenset             内容改变，地址必须改变

类型转换：
str   转     int，list，set，tuple
----------------------------------------------------------------------------------------------
文件修改两种方式：
1、打开全部读入内存修改，再以w模式打开，将内存中的内容写入文件，速度快，不适合大文件
2、打开两个文件，读入一行写入一行，最后使用os.remove(文件路径)删除旧文件，然后修改新文件名，占内存小
f.seek()
读取大文件：
使用readline，每次读取一行，当读到末尾就退出
f = open ('信息.txt')
while True:
    t = f.readline()
    if not t:
        break
    print(t)
f.close()

---------------------------------------------------------------------------------------------------
函数：
申请内存空间保存函数体代码，内存地址绑定函数名，定义会检测语法
func(1, 3) * 10        # 函数的返回值乘10
func(func(1, 2), 3)   # 函数当参数
关键字参数：key=value，位置参数放在关键字参数前面，不能重复传参数
默认参数在函数定义阶段赋值：def func(a=3)  而列表做参数会改变
默认参数不应该使用可变类型，如列表
可变长参数：*与**，*args是元组格式、**kwargs字典格式，*args放在**kwargs前面
解包：*[1,2,3]<==>1 2 3  ，*'hello'<==>h e l l o，单个*号解包字典只获得key，*{1：2，3：4}  <==>1 2
def fun(a,b,*,x,y)  # *后面的参数为命名关键字参数，传值k-v：x=1,y=2
fun(**字典)           解包字典，传给形参**kwargs再封包

lambda匿名函数：
精简，用在临时使用一次的场景
方式一：fun = lambda x, y：x + y
fun(1, 2)
返回：3

方式二：res = (lambda x:x+1)(2)   相当于立即执行函数
方式三：[lambda x: x+1 for i in range(10)]

类型提示：
def fun(name:str, age:int)->int:        
    pass
------------------------------------------------------
def func():
    print(x)
x = 1
func()
输出：1
以函数定义阶段为准

x = 111
def func()
    print(x)
    x = 222
func()
报错，在定义前使用x，作用域
--------------------------------------------------------
全局作用域：global用在改变不同作用域的不可变类型
nonlocal：局部作用域的修改，不是本地，在当前层的外一层开始

闭包：
拥有函数功能，还有函数数据
一个函数里面有另一个函数，内部函数使用到外层函数的变量，返回内部函数
def fun(a):
    def fun2(b):
        print(a+b)
    return fun2

my_fun = fun(1)   my_fun得到fun的返回值fun2的函数引用
my_fun(2)   执行fun2函数
输出：3

nonlocal：在闭包里使用
-------------------------------------------------------------------
装饰器：
改变原函数的指向，在不改变原代码，还是原来的调用方式上，给它加功能
在闭包基础上，传入参数为函数的引用
通用装饰器：有返回值，有不定参数
def f1(func):     # 参数是一个函数对象
    def wrapper(*args, **kwargs):   # 跟被装饰的函数参数跟返回值要一样
         ....
         res = func(*args, **kwargs)
         .....
         return res
    return wrapper

@f1    #  等价于 test = f1(test)， f1的返回值是一个函数引用，@f1叫语法糖，因为更简洁了
test()

多个装饰器先装下层的，调用则先最外层一层一层下去：
加载顺序：自下而上
执行顺序：自上而下
@f1  # fun = f1(fun = f2(fun))
@f2  # fun = f2(fun)
fun()
先执行@f2

带参数装饰器：
在外面再包一层，先调用参数，在返回内层装饰器
def s(num)
    def f1(func):
        def wrapper(*args, **kwargs):
             ......
             res = func(*args, **kwargs)
             ......
             return res
        return wrapper
    return f1

@s(num=100)    
test()

类装饰器:
@MyClass
test()
或
@MyClass.静态方法
test()
------------------------------------------------------------------
help(对象)  查看帮助信息

绝对导入：从包开始
相对导入：从当前位置开始，不能超出包的位置
循环导入问题

print(__file__)  # 当前文件的绝对路径

判断文件是否存在：os.path.exists(文件路径)
删除文件：os.remove(文件路径)
----------------------------------------------------------------------------------
更新笔记
r'\'不能单独出现,或在末尾出现






