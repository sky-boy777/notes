java是强类型语言

hello world
创建文件Hello.java，写入
public class Hello {
	/*
	多行注释
	*/

	/**
	文档注释
	*/
	public static void main(String[] args){
		System.out.println("hello world");  // println中是小写的L而不是大写的i
	}
}
javac Hello.java                                编译，成字节码得到类名的文件Hello.class
javac -encoding utf-8 h.java             指定编码格式
java Hello                                        运行，后面不用加后缀名

命名规则：字母、数字、下划线、$，不能数字开头，不能含有空格

一个文件可以多个class，但只能有一个public class
------------------------------------------------------------------------------
关键字：
abstract
表明类或者成员方法具有抽象属性
assert
断言，用来进行程序调试
boolean
基本数据类型之一，声明布尔类型的关键字
break
提前跳出一个块
byte
基本数据类型之一，字节类型
case
用在switch语句之中，表示其中的一个分支
catch
用在异常处理中，用来捕捉异常
char
基本数据类型之一，字符类型
class
声明一个类
const
保留关键字，没有具体含义
continue
回到一个块的开始处
default
默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现
do
用在do-while循环结构中
double
基本数据类型之一，双精度浮点数类型
else
用在条件语句中，表明当条件不成立时的分支
enum
枚举
extends
表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口
final
用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量
finally
用于处理异常情况，用来声明一个基本肯定会被执行到的语句块
float
基本数据类型之一，单精度浮点数类型
for
一种循环结构的引导词
goto
保留关键字，没有具体含义
if
条件语句的引导词
implements
表明一个类实现了给定的接口
import
表明要访问指定的类或包
instanceof
用来测试一个对象是否是指定类型的实例对象
int
基本数据类型之一，整数类型
interface
接口
long
基本数据类型之一，长整数类型
native
用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的
new
用来创建新实例对象
package
包
private
一种访问控制方式：私用模式
protected
一种访问控制方式：保护模式
public
一种访问控制方式：共用模式
return
从成员方法中返回数据
short
基本数据类型之一,短整数类型
static
表明具有静态属性
strictfp
用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范
super
表明当前对象的父类型的引用或者父类型的构造方法
switch
分支语句结构的引导词
synchronized
表明一段代码需要同步执行
this
指向当前实例对象的引用
throw
抛出一个异常
throws
声明在当前定义的成员方法中所有需要抛出的异常
transient
声明不用序列化的成员域
try
尝试一个可能抛出异常的程序块
void
声明当前成员方法没有返回值
volatile
表明两个或者多个变量必须同步地发生变化
while
用在循环结构中
----------------------------------------------------------------------------
变量：
先声明，后使用：类型，名字，值
赋值后才能使用变量，作用域在{ }内，同一个作用域不能声明两个同名的变量

数据类型：八种
基本数据类型：数值（整型：byte, short, int, long; 浮点型：float,double）、字符型(char)、布尔(boolean)
引用数据类型：类（class）、接口（interface）、数组（[array]）

byte：1字节=8bit    -128~127
short：2字节           -2^15~2^15-1
***int：4字节               -2^31~2^31-1(约21亿)
long：8字节            -2^63~2^63-1             声明时需要加“l”或“L”，long num = 22443243L;

单精度float：4字节             -3.403e38~3.403e38          float类型定义时要加“f”或“F”
***双精度double：8字节          -1.798e308~1.798e308

char(1字符=2字节)    通常使用单引号''，只能写一个字符            char c = 'a';      不能char c = 'ab';
'\n', '\u0043'   都是一个字符

自动类型提升：
使用大范围接收小范围:
byte、char、short----->int----->long---->float---->double
int num = byte + int       应该使用int类型接受或更大范围的类型
 int n = 'a' + 1;                98，a的ASCII码为97
char c = 'a' + 1;               b
byte、char、short运算至少要用int接收

强制类型转换：
double d = 12.9；
int i = (int)d;              强转为int类型，结果为12，大变小会损失精度
long l = 2323233；    后面没加“l”“L”，会变成int，超过整型范围编译报错
float后面一点要加“F”“f”，不然编译报错

String属于引用数据类型：String s = "djfkd";   // 字符串，使用双引号，char使用单引号且内容不能为空
String可以何8中数据类型做连接运算“+”，结果是String类型
String s = 3.5f + "";         3.5

原码取反得反码加1得补码，符号位除外
计算机底层都以补码保存数据

System.out.println();
println() 是一个方法。
System 是系统类。
out 是标准输出对象。
定义方法用小驼峰命名法，如：myName, 下划线也行my_name

System.gc();   //调用Java垃圾收集器

修饰符 返回值类型 方法名(参数类型 参数名){                    头
    ...
    方法体                                                                      体
    ...
    return 返回值;
}
如：public static int age(int birthday){...}

fun(double... nums) { }               double后面加三点...     可变参数
fun(1, 2, 3);
fun(new double[]{1, 2, 3});

finalize() 方法
Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。
例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。
protected void finalize()
{
   // 在这里终结代码
}
关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。
当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。

方法重载：
同一个类内，名字相同，参数类型不同
如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；
如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；
就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。
Java编译器根据方法签名判断哪个方法应该被调用。
方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。
重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。

构造方法：
当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。
通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。
不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，
默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。
一旦你定义了自己的构造方法，默认构造方法就会失效。
class MyClass {
  int x;
  MyClass(double... nums) {                // double...     可变参数
    x = 10;
  }
}


命令行参数传入main方法的args


 三元运算：num1 > num2 ? num1 : num2;


for循环的初始化部分声明的变量，其作用范围在整个循环。
但循环体内声明的变量其适用范围是从它声明到循环体结束


数组：
类型[] 名称 = 
double[ ][ ] myList = new double[大小][大小];          多维数组
double[ ] myList = {1, 3, 4.666};

for(int num: myList){}       迭代循环，num是数组元素, 类似python for ... in ...


日期：
import java.util.Date;     导入     或import java.util.*;

Date date = new Date();
System.out.println(date.toString());       使用，显示日期时间：Thu Sep 23 09:37:38 CST 2021


使用正则：
import java.util.regex.*;         导入相关类：Pattern, Matcher, PatternSyntaxException

boolean a = Pattern.matches(".*abc.*", "adjfabcdjfkd");      true, \\d+ 匹配多个数字，两个 \\ 代表其他语言中的一个 \
System.out.println("\\");       // 输出一个\，两个斜杠输出一个斜杠


Java 流(Stream)、文件(File)和IO
Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。
Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。
一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。


文件：
InputStream f = new FileInputStream("aa.txt");               打开读取
OutputStream f = new FileOutputStream("test.txt");       打开写入
try{
    byte b[] = {1,2,3,4,5};
    OutputStream os = new FileOutputStream("bb.txt");    打开写入，没有则创建
    os.write(b);                                                                   写入
    os.close();                                                                     关闭
			 
    InputStream f = new FileInputStream("bb.txt");            打开读取
    System.out.println(f.read());                                           
    f.close();
}catch(Exception e){
    System.out.println(e+"异常");
}


控制台输入
Scanner scan = new Scanner(System.in); 
if(scan.hasNext()){                 // 判断是否还有输入的数据或是否是指定数据类型，hasNextXxx，如hasNextLine、hasNextInt ......
    String s = scan.next();       // 接收输入值，第一个空格结束，nextLine()以回车结束，nextInt，nextFloat
}
System.out.println(str1);
scan.close();   // 关闭	

next():
1、一定要读取到有效字符后才可以结束输入。
2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。
3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。
next() 不能得到带有空格的字符串。

nextLine()：
1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。
2、可以获得空白。


异常：
try{

}catch(异常类型 变量){

}catch(exception e){

}finally{}    最后都会执行   

throws/throw:
public void withdraw(double amount) throws RemoteException, InsufficientFundsException{ 
	try{
	    throw new Exception();      抛出异常
	 }catch(Exception e){              捕获异常
	    System.out.println(e);
	}
}    

检查性异常：、
最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
运行时异常： 
运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。
错误： 
错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。

声明自定义异常：
在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。
所有异常都必须是 Throwable 的子类。
如果希望写一个检查性异常类，则需要继承 Exception 类。
如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。


面向对象：
只有单继承
封装、继承、多态

public 子类 extends 父类{ }

子类拥有父类非 private 的属性、方法
继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，
当一个类没有继承的两个关键字，则默认继承object

implements：
使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，
可以同时继承多个接口（接口跟接口之间采用逗号分隔）
public interface A {
    public void eat();
    public void sleep();
}
 
public interface B {
    public void show();
}

public class C implements A,B { }      类继承多个接口

super  父类
this     指向自己    

final：
final 关键字可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写           
1、final class 类名 { }
2、final 返回类型 名称（）{}
实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。
被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final

父类构造方法有参数需要在子类使用super调用，无参数则自动调用












