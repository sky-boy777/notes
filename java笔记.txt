java是强类型语言

hello world
创建文件Hello.java，写入

/**
 文档注释
*/
public class Hello {
	
	/**
 	 这个方法用来......
	@author 作者
	@version 版本
	@param 参数字符串列表
	@return 返回String
	*/
	public static void main(String[] args){
		System.out.println("hello world");  // println中是小写的L而不是大写的i
	}
}

/*
  多行注释
*/

javadoc从包、公有类与接口、公有的和受保护的构造器及方法、公有的和受保护的域中抽取文档注释信息

注释中出现\u会转译，编译会报错: // 这是\u注释

可以链式编程

javac Hello.java     编译，成字节码得到类名的文件Hello.class，内部使用了其他类时会自动编译对应的类文件
javac He*.java                                  使用通配符
javac -encoding utf-8 h.java             指定编码格式
java Hello                                        运行，后面不用加后缀名

命名规则：字母、数字、下划线、$，不能数字开头，不能含有空格

一个文件可以多个class，但只能有一个public class
------------------------------------------------------------------------------
关键字：
abstract
表明类或者成员方法具有抽象属性
assert
断言，用来进行程序调试
boolean
基本数据类型之一，声明布尔类型的关键字
break
提前跳出一个块
byte
基本数据类型之一，字节类型
case
用在switch语句之中，表示其中的一个分支
catch
用在异常处理中，用来捕捉异常
char
基本数据类型之一，字符类型
class
声明一个类
const
保留关键字，没有具体含义
continue
回到一个块的开始处
default
默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现
do
用在do-while循环结构中
double
基本数据类型之一，双精度浮点数类型
else
用在条件语句中，表明当条件不成立时的分支
enum
枚举
extends
表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口
final
用来说明最终属性，表明一个类不能派生出子类（不能继承），或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量
finally
用于处理异常情况，用来声明一个基本肯定会被执行到的语句块
float
基本数据类型之一，单精度浮点数类型
for
一种循环结构的引导词
goto
保留关键字，没有具体含义
if
条件语句的引导词
implements
表明一个类实现了给定的接口
import
表明要访问指定的类或包
instanceof
用来测试一个对象是否是指定类型的实例对象
int
基本数据类型之一，整数类型
interface
接口
long
基本数据类型之一，长整数类型
native
用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的
new
用来创建新实例对象
package
包
private
一种访问控制方式：私用模式
protected
一种访问控制方式：保护模式
public
一种访问控制方式：共用模式
return
从成员方法中返回数据
short
基本数据类型之一,短整数类型
static
表明具有静态属性
strictfp
用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范
super
表明当前对象的父类型的引用或者父类型的构造方法
switch
分支语句结构的引导词
synchronized
表明一段代码需要同步执行
this
指向当前实例对象的引用
throw
抛出一个异常
throws
声明在当前定义的成员方法中所有需要抛出的异常
transient
声明不用序列化的成员域
try
尝试一个可能抛出异常的程序块
void
声明当前成员方法没有返回值
volatile
表明两个或者多个变量必须同步地发生变化
while
用在循环结构中
----------------------------------------------------------------------------
变量：
先声明，后使用：类型，名字，值
赋值后才能使用变量，作用域在{ }内，同一个作用域不能声明两个同名的变量

数据类型：八种
基本数据类型：数值（整型：byte, short, int, long; 浮点型：float,double）、字符型(char)、布尔(boolean)
引用数据类型：类（class）、接口（interface）、数组（[array]）

byte：1字节=8bit    -128~127
short：2字节           -2^15~2^15-1
***int：4字节           -2^31~2^31-1(约21亿)
long：8字节            -2^63~2^63-1             声明时需要加“l”或“L”，long num = 22443243L;

单精度float：4字节             -3.403e38~3.403e38          float类型定义时要加“f”或“F”
双精度double：8字节          -1.798e308~1.798e308，两倍的float

char(1字符=2字节)    通常使用单引号''，只能写一个字符            char c = 'a';      不能char c = 'ab';
'\n', '\u0043'   都是一个字符

整型和布尔型不能相互转换，if(0){  }  将会编译报错

final int XXX;             // 使用find关键字定义常量，一旦赋值不能更改
static final int XXX;   //  一个类常量

基本类型对应的包装类表如下：
基本类型	引用类型
boolean	Boolean
byte	Byte
short	Short
int	Integer
long	Long
float	Float
double	Double
char	Character

0x十六进制，0开头八进制，0b二进制
java7开始可以使用：int n = 1_000_000;  可以加下划线

自动类型提升：
使用大范围接收小范围:
byte、char、short----->int----->long---->float---->double
int num = byte + int       应该使用int类型接受或更大范围的类型
 int n = 'a' + 1;                98，a的ASCII码为97
char c = 'a' + 1;               b
byte、char、short运算至少要用int接收

强制类型转换：
double d = 12.9；
int i = (int)d;              强转为int类型，结果为12，大变小会损失精度
long l = 2323233；    后面没加“l”“L”，会变成int，超过整型范围编译报错
float后面一点要加“F”“f”，不然编译报错

String属于引用数据类型：String s = "djfkd";   // 字符串，使用双引号，char使用单引号且内容不能为空
String可以何8中数据类型做连接运算“+”，结果是String类型
String s = 3.5f + "";         3.5

在将父类转换成子类之前，应该使用instanceof进行检查
if (o instanceof DemoClass) {
	DemoClass o = (DemoClass) o;  // 尽量少用
}

只能在继承层次内进行类型转换

null instanceof Object  ==> false

String s = String.valueOf(2);   数字转为字符串

原码取反得反码加1得补码，符号位除外
计算机底层都以补码保存数据

public static strictfp void main(String[] args){}    strictfp关键字，在main方法或类中将使用严格的浮点计算

byte s = 1;
s += 2;                      不会改变变量本身的类型
s = (byte)(s + 2);        需要转换类型，不然编译出错，数字默认int类型

浮点数除0会得到无穷大或NaN：3.14/0 得到Infinity，整数除0运行报错，编译不报错

instanceof：是 Java 的保留关键字，作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 类型

负数求余得负数

逻辑运算：&&、||、!，前两个是短路运算
无短路：逻辑与&（两个都为真则真）、逻辑或|（有一个真则真）、逻辑异或^(不同为true)
位运算符是直接对整数的二进制的运算：左移<<乘2、>>除2、无符号右移>>>全部补0

交换两个数的位置：
1、定义第三个变量或如下
2、
num1 = num1 + num2;
num2 = num1 - num2;
num1 = num1 - num2
3、异或
num1 = num1 ^ num2;
num2 = num1 ^ num2;
num1 = numq ^ num2;


斐波那契数列：
if ((n == 0) || (n == 1))
            return number;
        else
            return fibonacci(n - 1) + fibonacci(n - 2);

System.out.println();
println() 是一个方法。
System 是系统类。
out 是标准输出对象。
定义方法用小驼峰命名法，如：myName, 下划线也行my_name

System.gc();   //调用Java垃圾收集器

修饰符 返回值类型 方法名(参数类型 参数名){                    头
    ...
    方法体                                                                      体
    ...
    return 返回值;
}
如：public static int age(int birthday){...}

可变参数:
必须再最后一个位置，且只能有一个可变参数
fun(String s, int ... n) { }          长度：nums.length，js也有这种
传参
fun("str", 1, 2, 3);   
fun("str", new double[]{1, 2, 3});

finalize() 方法
Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。
例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。
protected void finalize()
{
   // 在这里终结代码
}
关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。
当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。


命令行参数传入main方法的args：java T 参数1 参数2 

 三元运算：int num = num1 > num2 ? num1 : num2;
效率比if-else高

方法传参：
1、按值调用（值的拷贝），java使用按值调用
2、按引用调用（地址）

static：
声明静态方法、变量
静态域，每个类只有一个静态域，所有实例对象都共享这个静态域，静态域属于类，python中的属性，而不是类属性
例如，计算器
     private static final int a = 0;   // 静态常量，用的比较多，静态变量少
     public M(){    // 构造函数
	a++;  // 没new一个对象a就加1
    }
静态方法跟python的静态方法差不多，它没有this参数，不能使用实例属性、方法，this等价于python中的self，可以访问静态变量
建议使用"类名.静态方法()"调用静态方法，"对象.静态方法()"也能调用


从键盘获取输入：Scanner类
import java.util.Scanner;
Scanner scan = new Scanner(System.in);
int num = scan.nextInt();       接收int类型，nextFloat(), nextDouble(), nextLine()

Math.random();   随机数返回[0,1)区间double类型
任意区间整数公式：[min, max] ==> (int)(Match.random() * (max - min + 1) + min)

for循环的初始化部分声明的变量，其作用范围在整个循环。
但循环体内声明的变量其适用范围是从它声明到循环体结束
for(int i = 0;;){}
i不能在外面使用

流程控制：
只有一行可以省略花括号，不建议这样

if(表达式){                             if-else结构
}else if(表达式){
}else{ 
}

switch(1){            // switch-case结构执行效率比if-else高，根据表达式值匹配常量找到入口
   case 常量1:       // 表达式的值的类型只能是6种：byte、short、char、int、枚举、String
      语句;
      break;     // break可选
   case:          // 多个case相同，可以合并
   case "1":    // 编译报错，String无法转换为int
   case:
      语句;
      break;
   default:      // default可选，放在哪里都行，一般在最后
      语句;
}
case后常量会尝试跟switch表达式的类型进行转换，有些类型不能相互转换，会编译报错

循环：
1、for(int i=0; i<10; i++){ }
2、while( ){ }
3、do{ }while( )
4、for(int i : intArr){ }  增强for循环

for(; ;) <==> while(true)

break 跳出当前层循环
continue 结束本次循环，开始下一次
return；   能结束多层循环

标签可以指定跳出的循环，标签可以使用在任何地方，如if语句
my_label:for(){
   for(){ break my_label; }  // 跳出指定标识的一层循环，continue则结束指定标识处本次循环
}

System.currentTimeMillis();    1970年1月1日 00：00：00 至今的毫秒数

衡量代码的优劣：正确性、可读性、健壮性(鲁棒性)、高效率(时间复杂度）与低存储(空间复杂度）


数组：
相同类型数据按一定顺序排列的集合，数组是引用数据类型，元素也可以是应用数据类型
一旦初始化完成，长度就确定了，长度一旦确定，就不能更改

使用：
声明、分配空间、赋值
1、类型[] 名称 = new 类型[]{1, 2, 3, 4 };                          声明并初始化，静态初始化
2、类型[] 名称 = new 类型[20];                                      动态初始化 ，***标准写法***
3、类型[] 名称 = {1, 2, 3};                              声明并初始化，叫类型推断

二维数组声明方式：
int[ ][ ] arr = new int[3][4];    // int[ ][ ]{ {1, 2, 3}, {4 , 5, 6} }    
int[ ][ ] arr = new int[3][ ];     // 也可以这样  
int arr[ ][ ] = new int[3][4]; 
int[ ] arr[ ] = new int[3][4]; 
int[][] arr = { {1, 2, 3}, {4 , 5, 6} } ;       类型推断，省略new

int[] arr = {1, 2, 3};             
arr.length;                   属性，获取数组长度
arr[2].length;               多维数组第三维长度

二维数组遍历：
for（int i = 0; i < arr.length; i++）{
    for(int j = 0; j < arr[i].length; j++){
        System.out.println(arr[i][j]);
    }
}

数组反转：
第一个与最后一个交互，第二个与倒数第二个交换。。。，时间效率高
for (i = 0; i < n / 2; i++) {
            t = a[i];
            a[i] = a[n - i - 1];
            a[n - i - 1] = t;
}

查找重复元素：
 int count=0;
        for(int j=0;j<a.length;j++) {
            for(int k =j+1;k<a.length;k++) {
                if(a[j]==a[k]) {
                    count++;
                }
            }
            if(count==1)
               System.out.println( "重复元素 : " +  a[j] );
            count = 0;
        }

数组默认初始化值：
整型byte、short、int、long         0
浮点型float、double                    0.0
char类型                                     '\u0000', cha[1]==0
布尔                                            false
引用数据类型String                       null, 不是"null"
二维数组的第一层默认值地址，最后一层跟一维数组一样
int[ ][ ] arr = new int[3][ ];   // arr[0] 为null，任何类型都是null，因为是引用类型(引用地址)

for(int num: myList){}       迭代循环，num是数组元素, 类似python for ... in ...

数组的内存解析：
堆（heap）：存放局部变量
栈（stack）：存放new出来的结构（对象，数组），栈存放16进制地址值 

数组工具类：Arrays
Arrays.equals(arr1, arr2)        判断两个数组是否相等
toString(arr1)                       输出数组信息
fill(arr1, "值")                       将指定数组填充到数组中，全部填充为同一个"值"
sort(arr1)                            数组排序
binarySearch(arr1， 3)        排序后的数组进行二分查找指定值：3，返回索引
Arrays.asList(arr)；              数组转集合

十大排序算法：
选择排序： 直接选择排序、堆排序
交换排序： 冒泡排序、快速排序 O(nlog(n))，内部排序最快的是快速排序
插入排序：直接插入排序、折半插入排序、shell排序
归并排序
桶式排序
基数排序

字符串类加效率比较低，使用类：StringBuilder b = new StringBuilder();  b.append("xx");
    

垃圾回收机制：引用计数
排序算法的稳定性：a、b两个值相等，排序后a、b的先后次序不变，则是稳定的


基本数据类型赋值是复制，再创建一个，传参传真实值
引用数据类型是地址传递，都指向同一个，方法传参传地址


public class T {
	public static void main(String[] args) {
		T t = new T();    // 可以这样使用
	}
}

char[] arr = new char[]{'a', 'b'};
System.out.print(arr);   // 输出：ab，而不是地址值，其他的是输出地址值

日期：
import java.util.Date;     导入     或import java.util.*;

Date date = new Date();
System.out.println(date.toString());       使用，显示日期时间：Thu Sep 23 09:37:38 CST 2021


import static java.lang.Math.*;    导入指定包下类或接口的静态结构、属性、方法
PI、E、......

int i = 1;
double d = 3.14;
i += 3.14;   将会发生强制类型转换：(int)(x + 3.14)


使用正则：
import java.util.regex.*;         导入相关类：Pattern, Matcher, PatternSyntaxException

boolean a = Pattern.matches(".*abc.*", "adjfabcdjfkd");      true, \\d+ 匹配多个数字，两个 \\ 代表其他语言中的一个 \
System.out.println("\\");       // 输出一个\，两个斜杠输出一个斜杠


Java 流(Stream)、文件(File)和IO
Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。
Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。
一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。

文件：
InputStream f = new FileInputStream("aa.txt");               打开读取
OutputStream f = new FileOutputStream("test.txt");       打开写入
try{
    byte b[] = {1,2,3,4,5};
    OutputStream os = new FileOutputStream("bb.txt");    打开写入，没有则创建
    os.write(b);                                                                   写入
    os.close();                                                                     关闭
			 
    InputStream f = new FileInputStream("bb.txt");            打开读取
    System.out.println(f.read());                                           
    f.close();
}catch(Exception e){
    System.out.println(e+"异常");
}

实例：
import java.io.*;     // 导入

public class T {
   public static void main(String args[]){
                  try{    
 		  // 写入
		  BufferedWriter out = new BufferedWriter(new FileWriter("aa.txt",true));  // true为追加
		  out.write("jdfkdjf");   // 写入
		  out.close();                // 关闭

		  // 读取
		  BufferedReader in = new BufferedReader(new FileReader("a.txt"));  
		  System.out.println(in.readLine());
		  System.out.println(in.readLine());  // 文件结束为null
                                  in.close();

		  // 其他操作
		  File f = new File("a.txt");
                                  f.length();     // 文件大小（字节）
		  f.exists()；   // 是否存在 
   		  f.isFile()；   //  是否是文件
		  f.delete();   // 删除
 		f.renameTo(new File("bbb.txt"));  // 重命名
		f.lastModified()；// 文件最后修改时间

		// 创建文件
		File f = new File("xxx.txt");
		f.createNewFile();  

		File.createTempFile("文件名前缀", ".txt", new File("E:/"));  // 在指定目录下创建文件

		System.getProperty("user.dir");  // 返回当前工作目录

		// 文件内容复制到另一个文件
		InputStream in = new FileInputStream(new File("srcfile"));
        		OutputStream out = new FileOutputStream(new File("destnfile"));
        		byte[] buf = new byte[1024];
        		int len;
        		while ((len = in.read(buf)) > 0) {  // 文件的字节大小
            		    out.write(buf, 0, len);
        		}
        		in.close();
        		out.close();
	   }catch(IOException e){
		   System.out.print(e);   //  必须要捕获异常
	   }
   }
}


java.lang包中的类不需要import导入，其他需要


读取控制台输入：
Scanner类 + System.in

import java.util.*;

Scanner scan = new Scanner(System.in); 
if(scan.hasNext()){                 // 判断是否还有输入的数据或是否是指定数据类型，hasNextXxx，如hasNextLine、hasNextInt ......
    String s = scan.next();       // 接收输入值，第一个空格结束，nextLine()以回车结束，nextInt，nextFloat
}
System.out.println(str1);
scan.close();   // 关闭	

next():
1、一定要读取到有效字符后才可以结束输入。
2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。
3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。
next() 不能得到带有空格的字符串。

nextLine()：
1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。
2、可以获得空白。

Console类适用于从控制台读取密码

块作用域：
包含在{ }内，不能再嵌套的块中定义两个同名的变量：{ int n;  { int n; } }，编译报错


异常：
try{

}catch(异常类型 变量){

}catch(exception e){

}finally{}    最后都会执行   

throws/throw:
public void withdraw(double amount) throws RemoteException, InsufficientFundsException{ 
	try {
	    throw new Exception("我的异常");      抛出异常
	 }catch(Exception e) {              捕获异常
	    System.out.println(e);
	    e.printStackTrace();     // 获取异常堆栈信息
	   }finally {
	   // 最后执行
	}
}    

多个catch块中的异常出现继承关系，父类异常catch块放在最下面（Exception）

检查性异常：、
最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
运行时异常： 
运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。
错误： 
错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。

声明自定义异常：
在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。
所有异常都必须是 Throwable 的子类。
如果希望写一个检查性异常类，则需要继承 Exception 类。
如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。


面向对象OOP：
只有单继承
封装、继承、多态

属性 = 成员变量 = field = 域、字段

修饰符：
1、访问修饰符
2、非访问修饰符
修饰符用来定义类、方法或者变量，通常放在语句的最前端
局部变量不能使用访问修饰符

访问修饰符：
使用访问控制符来保护对（类、属性、方法、构造器）的访问
Java 支持 4 种不同的访问权限，从小到大：
1、private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰外部类
2、缺省 (即默认，什么也不写）: 在同一包内可见，使用对象：类、接口、变量、方法。
3、protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰外部类
4、public : 对所有类可见。使用对象：类、接口、变量、方法

类（class）只能用public或缺省修饰

非访问修饰符：
1、static  修饰符，用来修饰类方法和类变量。
2、final   修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，
              修饰的变量为常量，是不可修改的。
3、abstract              修饰符，用来创建抽象类和抽象方法。
4、synchronized 和 volatile      修饰符，主要用于线程的编程。volatile 修饰符volatile修饰的成员变量在每次被线程访问时，
                                               都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。
                                              这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个 volatile 对象引用可能是 null。
                                              synchronized关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。
5、transient             修饰符，序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量，不会持久化保存
                              该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

局部变量没有默认初始化值，赋值后才能使用，不然编译报错
局部变量加载到栈空间，属性（非static）加载到堆空间

方法：
访问修饰符 返回类型 方法名( 参数类型 变量 ){  }
public void  log( String num ){  }

方法里不能再定义方法

匿名对象：不赋值，直接new，new MyClass().方法名()，使用：obj.fun( new MyClass() )
匿名数组：new int[ ]{1, 2, 3, 4}; 

构造方法或构造器：
任何一个类都有构造器
当一个对象被创建时候（new），构造方法用来初始化该对象。构造方法和它所在类的名字相同，构造方法没有返回值。
通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。
不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，
默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。
一旦你定义了自己的构造方法，默认构造方法就会失效。
可以有一个以上的构造方法。
构造方法伴随new操作一起调用。

class MyClass {
  public MyClass() { }                // 构造器，默认是空参构造器，默认权限修饰符跟随class
  public MyClass(int i){ }           // 构造器重载，重载后一定要有一个空参构造器
 }

自定义了构造器后，系统不会提供默认的无参构造器

java的所有对象都是在堆中构造的

对象数组：
MyClass[ ] my = MyClass[20];    // 数组元素为对象

MyClass a;  // 声明一个这个类的变量

同一个目录下两个文件，可以直接new另一个文件的类
test目录
   Main.java
   Test.java

类设计的技巧：
一定要保证数据私有
一定要对数据初始化
不要在类中使用过多的基本类型：int，String。。。。
不是所有的域都需要独立的域访问器和域更改器：getxx、setxx
将职责过多的类进行分解
类名和方法名要能体现他们的职责
优先使用不可变的类

继承：
父类（超类、基类）
子类（派生类、孩子类）

继承能获取符类的所有属性跟方法，因为封装性的影响，子类使用不了符类私有的东西，但确实获取了私有的结构

父类型数组可以转换成子类型数组，不需要强制类型转换

所有类的顶层类为Object

public 子类 extends 父类{ }

子类拥有父类非 private 的属性、方法
继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，
当一个类没有继承的两个关键字，则默认继承object

implements：
使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，
可以同时继承多个接口（接口跟接口之间采用逗号分隔）
public interface A {
    public void eat();
    public void sleep();
}
 
public interface B {
    public void show();
}

public class C implements A,B { }      类继承多个接口

super：  
父类，显示的调用父类的方法或属性，子类可以使用super来访问父类的私有域，super.私有方法()、属性

super()必须声明在子类构造器首行
构造器的首行没有显示的声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类种空参的构造器super()
在构造器中，“this(形参列表)”或“super(形参列表)”不能同时出现
在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”，调用父类的构造器

this：     
当前对象，类似python shelf
在其他方法里面调用构造器：this(参数);
int age;
public fun(int age){
	this(age);  // 调用构造器，必须在首行，调用同一个类的***另一个***构造器
	this.age = age;
}    

初始化块：
在一对花括号内，先运行初始化块才运行构造器，建议将块放在定义变量的后面
int a;
int b;
{           // 实例域初始化
  a = 1;
  b = 2;
}

static{   // 静态域初始化
  ...
}

变量默认值：数值型0、布尔型false、对象型null

import java.util.Random;
new Random().nextInt(3);  // 返回一个0到n-1之间的随机整数

final：
final 关键字可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写           
1、final class 类名 { }
2、final 返回类型 名称（）{}
实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。
声明为 final 的类，只有方法自动地声明为 final

父类构造方法有参数需要在子类使用super调用，无参数则自动调用

重写（覆盖）：
重写是子类对父类的允许访问的方法的实现过程进行重新编写, *** 返回值 和 形参 ***不能改变。即外壳不变，核心重写！
重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。
重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。
例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法
的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能
抛出 IOException 的子类异常。

重写规则：
方法名跟参数列表必须相同
返回类型与被重写方法的返回类型可以不相同（void除外），但是必须是父类返回值的子类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
返回值是void，则重写也要返回void。
访问权限要大于等于父类方法的访问权限，例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
父类的成员方法只能被它的子类重写。
声明为 final 的方法不能被重写。
声明为 static 的方法不能被重写，但是能够被再次声明。
子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，
或者比被重写方法声明的更广泛的强制性异常，反之则可以。构造方法不能被重写。

重载(Overload)：
***同一个类内，方法名相同，参数类型不同，或参数顺序不同***
如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；
如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；
就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。
Java编译器根据方法签名判断哪个方法应该被调用。
方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。
重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。

如何确定调用哪个方法：方法的签名（方法名 + 参数列表） 

重载规则:
被重载的方法必须改变参数列表(参数个数或类型不一样)；参数顺序不同也是重载
被重载的方法可以改变返回类型；
被重载的方法可以改变访问修饰符；
被重载的方法可以声明新的或更广的检查异常；
方法能够在同一个类中或者在一个子类中被重载。
无法以返回值类型作为重载函数的区分标准

show(int ... a){} 等于  show(int[ ] b){}    

多态：
多态是同一个行为具有多个不同表现形式或形态的能力。
现实中，比如我们按下 F1 键这个动作：
      如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；
      如果当前在 Word 下弹出的就是 Word 帮助；
      在 Windows 下弹出的就是 Windows 帮助和支持。
同一个事件发生在不同的对象上会产生不同的结果。

多态的优点
1. 消除类型之间的耦合关系
2. 可替换性
3. 可扩充性
4. 接口性
5. 灵活性
6. 简化性

多态存在的三个必要条件：
继承
重写
父类的引用指向子类对象：Parent p = new Child();

class B extends A
A obj = new B();  // 对象的多态性：父类的引用指向子类的对象
boj.eat();  // 多态的使用：当调用子父类同名同参的方法时，执行的是子类重写父类的方法-----虚拟方法调用

x.eat()
y.eat()
public void fun(Object obj){
    obj.eat();
}
obj.fun(new X);  // x.eat()
obj.fun(new Y);  // y.eat()

传入不同对象，执行两个对象中相同的方法，输出不同，省去了方法重载

多态的使用：虚拟方法调用。
有了对象多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子
类重写父类的方法。
总结：
编译时看左边（A），运行时看右边（B）

对象的多态性只适用于方法，不适用于属性（编译和运行都看左边)

方法调用那一刻才确定要调用的具体方法，动态绑定，就是多态

内存中实际上加载了子类特有的方法跟属性，由于变量声明为父类类型，导致编译时
只能调用父类中声明的方法跟属性。子类特有方法跟属性不能调用。除非强制类型转
换（向下转型：父类--->子类）。B obj = （B）a；


Java 抽象类：
在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，
如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。
父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。
在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。

抽象方法：
如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，
那么你可以在父类中声明该方法为抽象方法。
Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。
抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。

public abstract class Demo{                    // 抽象类
	......
	public abstract double test();  // 抽象方法，只有名字，没有方法体，
	......
{

声明抽象方法会造成以下两个结果：
1、如果一个类包含抽象方法，那么该类必须是抽象类。
2、任何子类必须重写父类的抽象方法，否则，该子类也必须声明为抽象类。
最终，必须由子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。

抽象类总结规定
1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

Java 接口：
接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。
一个类通过继承接口的方式，从而来继承接口的抽象方法。

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。
另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

接口与类相似点：
一个接口可以有多个方法。
接口文件保存在 .java 结尾的文件中，文件名使用接口名。
接口的字节码文件保存在 .class 结尾的文件中。
接口相应的字节码文件必须在与包名称相匹配的目录结构中。
接口与类的区别：
接口不能用于实例化对象。
接口没有构造方法。
接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。
接口不能包含成员变量，除了 static 和 final 变量。
接口不是被类继承了，而是要被类实现。
接口支持多继承。

接口特性：
接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。
接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。
接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

抽象类和接口的区别：
1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。
注：JDK 1.8 以后，接口里可以有静态方法和方法体了。
注：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为"默认方法"，默认方法使用 default 关键字修饰。
注：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去

接口声明：
[修饰符] interface 接口名称 [extends 其他的接口名] {
       public void eat();
       public void travel();
       // 抽象方法
       // 声明变量
}

接口有以下特性：
接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字
接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字
接口中的方法都是公有的

接口实现：
当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。
类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。
public class 类名 implements 接口名称[, 其他接口名称, 其他接口名称..., ...] { }

标记接口
最常用的继承接口是没有包含任何方法的接口。
标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。

标记接口作用：
简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。

标记接口主要用于以下两种目的：
1、建立一个公共的父接口：
正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。
例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。
2、向一个类添加数据类型：
这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，
但是该类通过多态性变成一个接口类型。

Java 枚举(enum)
Java 枚举是一个特殊的类，一般表示一组常量
Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。

实例：
enum Color{
    RED, GREEN, BLUE;
}
 
public class Test{
    public static void main(String[] args){
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}

内部类中使用枚举：
public class Test{
    enum Color{
        RED, GREEN, BLUE;
    }
 
    public static void main(String[] args){
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}

每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。
class Color
{
     public static final Color RED = new Color();
}

迭代枚举元素：
......
for (Color myVar : Color.values()) {
      System.out.println(myVar);
    }
......

values() 返回枚举类中所有的值。
ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。
valueOf()方法返回指定字符串值的枚举常量。

枚举类成员:
枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。
枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。
......
 public static void main(String args[]) {
		Color c1 = Color.RED;   // 自动执行枚举构造函数
   }
......
enum Color{
    RED, GREEN, BLUE;
 
    // 构造函数
    private Color(){
        System.out.println("Constructor called for : " + this.toString());
    }
 
    public void colorInfo(){
        System.out.println("Universal Color");
    }
}

执行结果：
Constructor called for : RED
Constructor called for : GREEN
Constructor called for : BLUE

Java 包(package):
为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间

包的作用:
1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字
     是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、
枚举（enumerations）和注释（annotation）等。

包名用小写，是标识符

包名命名规则：
建议使用公司域名逆序方式，因为域名是独一无二的
如，com.公司、com.公司.子包

包语句的语法格式为：
package pkg1[．pkg2[．pkg3…]];   // 一个点代表一层文件目录

例如,一个Something.java 文件它的内容
package net.java.util;  // 将类放入包中

public class Something {
   ...
}
那么它的路径应该是 net/java/util/Something.java 这样保存

import 导包:
在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前

import package1[.package2…].(classname|*);  // 导入指定包下的类或接口
同一个包下的类或接口不用导入

可以使用的类：所属包中的所有类，其他包中公有类（public class）

不能这样导入：import java.*.*;

java5后不需要设置类路径：CLASSPATH

Java 数据结构
Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：

枚举（Enumeration）
位集合（BitSet）
向量（Vector）
栈（Stack）
字典（Dictionary）
哈希表（Hashtable）
属性（Properties）

枚举（Enumeration）
枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 
枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。
例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。

位集合（BitSet）
位集合类实现了一组可以单独设置和清除的位或标志。
该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一"位"，然后对位进行适当的设置或清除，
就可以对布尔值进行操作了。

向量（Vector）
向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。
和数组一样，Vector对象的元素也能通过索引访问。
使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。

栈（Stack）
栈（Stack）实现了一个后进先出（LIFO）的数据结构。
你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。
当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。

字典（Dictionary）
字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。
当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。
由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。

哈希表（Hashtable）
Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。
例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。
哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。

属性（Properties）
Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。
Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。


集合框架：
Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。
集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。
集合框架的类和接口均在java.util包中。
任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。

Collections.replaceAll(list, "a", "b");   // 将list里面的a全部替换成b  

ArrayList：
ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制

ArrayList<E> objName =new ArrayList<>();　 // 初始化，E: 泛型数据类型，用于设置 objName 的数据类型，只能为引用数据类型。
objName: 对象名
ArrayList<Integer> li=new Arraylist<>();     // 存放整数元素
ArrayList<Character> li=new Arraylist<>();   // 存放字符元素

......
import java.util.ArrayList;  // 引入 ArrayList 类
import java.util.Collections;

ArrayList<String> s = new ArrayList<String>();    存放字符串类型
s.add("a");            // 添加
s.get(1);                // 根据索引获取第二个元素
s.set(2, "b");          // 按索引设置值
s.remove(1);         // 删除索引的值
s.size();                 // 队列大小长度
for (String i : s) {   // 遍历
            System.out.println(i);
        }
Collections.sort(s);      排序,升序
......

方法	描述
add()	将元素插入到指定位置的 arraylist 中
addAll()	添加集合中的所有元素到 arraylist 中
clear()	删除 arraylist 中的所有元素
clone()	复制一份 arraylist
contains()	判断元素是否在 arraylist
get()	通过索引值获取 arraylist 中的元素
indexOf()	返回 arraylist 中元素的索引值
removeAll()	删除存在于指定集合中的 arraylist 里的所有元素
remove()	删除 arraylist 里的单个元素
size()	返回 arraylist 里元素数量
isEmpty()	判断 arraylist 是否为空
subList()	截取部分 arraylist 的元素
set()	替换 arraylist 中指定索引的元素
sort()	对 arraylist 元素进行排序
toArray()	将 arraylist 转换为数组
toString()	将 arraylist 转换为字符串
ensureCapacity()	设置指定容量大小的 arraylist
lastIndexOf()	返回指定元素在 arraylist 中最后一次出现的位置
retainAll()	保留 arraylist 中在指定集合中也存在的那些元素
containsAll()	查看 arraylist 是否包含指定集合中的所有元素
trimToSize()	将 arraylist 中的容量调整为数组中的元素个数
removeRange()	删除 arraylist 中指定索引之间存在的元素
replaceAll()	将给定的操作内容替换掉数组中每一个元素
removeIf()	删除所有满足特定条件的 arraylist 元素
forEach()	遍历 arraylist 中每一个元素并执行特定操作


LinkedList :
链表（Linked list）一种基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，
而是在每一个节点里存到下一个节点的地址。

import java.util.LinkedList;   导入
LinkedList<String> s = new LinkedList<String>();
s.add("xxx");  添加
s.addFirst("xx");    在头添加， removeFirst，getFirst   
s.addLast("xx");     在尾添加，
s.size();                 链表大小，用于遍历
for (String i : s) {
            System.out.println(i);
        }
System.out.print(s);  打印链表
s.subList(2, 4).clear();     // 删除链表 [2, 4) 区间的元素

方法	描述
public boolean add(E e)	链表末尾添加元素，返回是否成功，成功为 true，失败为 false。
public void add(int index, E element)	向指定位置插入元素。
public boolean addAll(Collection c)	将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。
public boolean addAll(int index, Collection c)	将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。
public void addFirst(E e)	元素添加到头部。
public void addLast(E e)	元素添加到尾部。
public boolean offer(E e)	向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。
public boolean offerFirst(E e)	头部插入元素，返回是否成功，成功为 true，失败为 false。
public boolean offerLast(E e)	尾部插入元素，返回是否成功，成功为 true，失败为 false。
public void clear()	清空链表。
public E removeFirst()	删除并返回第一个元素。
public E removeLast()	删除并返回最后一个元素。
public boolean remove(Object o)	删除某一元素，返回是否成功，成功为 true，失败为 false。
public E remove(int index)	删除指定位置的元素。
public E poll()	删除并返回第一个元素。
public E remove()	删除并返回第一个元素。
public boolean contains(Object o)	判断是否含有某一元素。
public E get(int index)	返回指定位置的元素。
public E getFirst()	返回第一个元素。
public E getLast()	返回最后一个元素。
public int indexOf(Object o)	查找指定元素从前往后第一次出现的索引。
public int lastIndexOf(Object o)	查找指定元素最后一次出现的索引。
public E peek()	返回第一个元素。
public E element()	返回第一个元素。
public E peekFirst()	返回头部元素。
public E peekLast()	返回尾部元素。
public E set(int index, E element)	设置指定位置的元素。
public Object clone()	克隆该列表。
public Iterator descendingIterator()	返回倒序迭代器。
public int size()	返回链表元素个数。
public ListIterator listIterator(int index)	返回从指定位置开始到末尾的迭代器。
public Object[] toArray()	返回一个由链表元素组成的数组。
public T[] toArray(T[] a)	返回一个由链表元素转换类型而成的数组。

以下情况使用 ArrayList :
频繁访问列表中的某一个元素。
只需要在列表末尾进行添加和删除元素操作。

以下情况使用 LinkedList :
你需要通过循环迭代来访问列表中的某些元素。
需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。


HashSet：
HashSet 基于 HashMap 来实现的，是一个元素唯一不重复的集合。
HashSet 允许有 null 值。
HashSet 是无序的，即不会记录插入的顺序。
HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 
    您必须在多线程访问时显式同步对 HashSet 的并发访问。
HashSet 实现了 Set 接口

import  java.util.HashSet;    导入
HashSet<Integer> s = new HashSet<Integer>();   实例化
s.add(12);          添加
s.remove(12);    删除
s.size();              元素个数
s.clear();            清空
for(int i: s){        遍历
	System.out.println(i);
}


HashMap：
HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。
HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。
HashMap 是无序的，即不会记录插入的顺序。
HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。

HashMap 的 key 与 value 类型可以相同也可以不同

import java.util.HashMap;  导入
HashMap<Integer, String> s = new HashMap<Integer, String>();  实例化
s.put(1, "xxx");   添加
s.get(1);             根据key获取值
s.remove(key);   根据key删除
s.keySet();          所有key
s.values();           所有值
System.out.println(s);    打印，{1=xxx, 2=xxx}

方法	描述
clear()	删除 hashMap 中的所有键/值对
clone()	复制一份 hashMap
isEmpty()	判断 hashMap 是否为空
size()	计算 hashMap 中键/值对的数量
put()	将键/值对添加到 hashMap 中
putAll()	将所有键/值对添加到 hashMap 中
putIfAbsent()	如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。
remove()	删除 hashMap 中指定键 key 的映射关系
containsKey()	检查 hashMap 中是否存在指定的 key 对应的映射关系。
containsValue()	检查 hashMap 中是否存在指定的 value 对应的映射关系。
replace()	替换 hashMap 中是指定的 key 对应的 value。
replaceAll()	将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。
get()	获取指定 key 对应对 value
getOrDefault()	获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值
forEach()	对 hashMap 中的每个映射执行指定的操作。
entrySet()	返回 hashMap 中所有映射项的集合集合视图。
keySet()	返回 hashMap 中所有 key 组成的集合视图。
values()	返回 hashMap 中存在的所有 value 值。
merge()	添加键值对到 hashMap 中
compute()	对 hashMap 中指定 key 的值进行重新计算
computeIfAbsent()	对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中
computeIfPresent()	对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。


Iterator（迭代器）：
Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。
Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。

迭代器 it 的两个基本操作是 next 、hasNext 和 remove。
调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。
调用 it.hasNext() 用于检测集合中是否还有元素。
调用 it.remove() 将迭代器返回的元素删除。

import java.util.Iterator;  导入

ArrayList<String> s = new ArrayList<String>();  
Iterator<String> it = s.iterator();   
it.next();      获取第一个元素
while(it.hasNext()){ 
     it.next();             迭代获取每一个元素    
     it.remove();        删除元素   
}

String[] s1 = s.toArray(new String[0]);   // 集合转数组


Object 类：
Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。

Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，
那么它就会自动继承 Object，成为 Object 的子类。

Object 类可以显示继承，也可以隐式继承

方法：
protected Object clone()     创建并返回一个对象的拷贝
boolean equals(Object obj)  比较两个对象是否相等

"abc".equals("abc")     // true，比较两个字符串是否相等
不建议使用 "=="，因为截取或+的字符串会放在不同的地方
"xabc".substring(0,3) == "xab"   // false
String str = "a";
"x" + str == "xa");      // false

null 不等于 ""，"".length() 为0

protected void finalize() 当 GC (垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。

Class<?> getClass() 获取对象的运行时对象的类

int hashCode() 获取对象的 hash 值

void notify() 唤醒在该对象上等待的某个线程

void notifyAll() 唤醒在该对象上等待的所有线程

String toString() 返回对象的字符串表示形式

void wait() 让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。

void wait(long timeout)
让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，
或者超过参数设置的timeout超时时间。

void wait(long timeout, int nanos)
与 wait(long timeout) 方法类似，多了一个 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 
所以超时的时间还需要加上 nanos 纳秒。


Java 泛型
Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，
该机制允许程序员在编译时检测到非法的类型。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

定义三个不同类型的数组，调用泛型方法
Integer[ ] intArray = { 1, 2, 3, 4, 5 };
Double[ ] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
Character[ ] charArray = { 'H', 'E', 'L', 'L', 'O' };

// 定义泛型方法 printArray                         
public static <E> void printArray( E[ ] arr )
   {
      // 输出数组元素            
         for ( E e : arr ){        
            System.out.printf( "%s ", e );
         }
         System.out.println();
    }

泛型类
泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。
和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。
一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一
个或多个参数，这些类被称为参数化的类或参数化的类型。

public class Box<T> {
  private T t;
  public void add(T t) {
    this.t = t;
  }
 
  public T get() {
    return t;
  }
 
  public static void main(String[] args) {
    Box<Integer> integerBox = new Box<Integer>();  // 或new Box<>(); 后面尖括号空
    Box<String> stringBox = new Box<String>();
 
    integerBox.add(new Integer(10));
    stringBox.add(new String("菜鸟教程"));
 
    System.out.printf("整型值为 :%d\n\n", integerBox.get());
    System.out.printf("字符串为 :%s\n", stringBox.get());
  }
}

Java SE 7 及更高版本中，<>只要编译器可以从上下文中确定或推断类型参数，就可以将调用泛型类的构造
函数所需的类型参数替换为空的类型参数集 ( )
Box<Integer> integerBox = new Box<>();

类型通配符
1、类型通配符一般是使用?代替具体的类型参数。例如 List<?> 在逻辑上是List<String>,List<Integer> 等
   所有List<具体类型实参>的父类。
2、类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。
   public static void num(List<? extends Number> data) { }
3、类型通配符下限通过形如 List<? super Number>来定义，表示类型只能接受Number及其三层父
   类类型，如 Object 类型的实例。

最常用的类型参数名称是：
E - 元素（被 Java 集合框架广泛使用）
K - 键
N - 数字
T - 类型
V - 值
S、U、V 等 - 第 2、3、4 种类型

Java 序列化：  
（对象序列化进文件，从文件反序列化对象出来）
Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、
有关对象的类型的信息和存储在对象中数据的类型。

将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，
还有对象中的数据类型可以用来在内存中新建对象。

整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。

类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。


网络编程（socket）：
import java.net.Socket;
import java.net.ServerSocket;

实例
import java.net.*;
 
public class T{
   public static void main(String[] args){
     try{
		System.out.print(InetAddress.getByName("www.baidu.com"));  // 获取主机跟ip地址
		InetAddress.getLocalHost()； 本地IP地址跟计算机名

		URL url = new URL("https://www.baidu.com");  // 创建请求url
		URLConnection con = url.openConnection();  // 发送请求
		con.getContentLength()；  // 获取大小（字节）
		con.getInputStream().close();  // 关闭

		Socket s = new Socket("www.baidu.com", 80);  // 连接到指定主机
		s.getInetAddress();  // 获取ip
		s.close();		

     }catch(Exception e){
		 System.out.println(e);
	 }
   }
}


发送邮件:
1、首先安装 JavaMail API 和Java Activation Framework (JAF) 
2、从 Java 网站下载最新版本的 JavaMail,最新版本的 JAF
3、下载并解压缩这些文件，在新创建的顶层目录中，您会发现这两个应用程序的一些 jar 文件。
您需要把 mail.jar 和 activation.jar 文件添加到您的 CLASSPATH 中。

如果你使用第三方邮件服务器如QQ的SMTP服务器，还要用户认证
用户认证部分：
如果需要提供用户名和密码给e-mail服务器来达到用户认证的目的，你可以通过如下设置来完成：
props.put("mail.smtp.auth", "true");
props.setProperty("mail.user", "myuser");
props.setProperty("mail.password", "mypwd");

关于QQ邮箱，还要设置SSL加密，加上以下代码即可：
MailSSLSocketFactory sf = new MailSSLSocketFactory();
sf.setTrustAllHosts(true);
props.put("mail.smtp.ssl.enable", "true");
props.put("mail.smtp.ssl.socketFactory", sf);


Java 多线程编程：
Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，
每条线程并行执行不同的任务。

多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。

进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，
它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。

多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。

start();    创建线程，就绪
run();      运行         
stop(); destroy();    强制停止

创建一个线程：
Java 提供了三种创建线程的方法：

1、通过实现 Runnable 接口
2、通过继承 Thread 类本身     
3、通过 Callable 和 Future 创建线程。

1、通过实现 Runnable 接口：
必须调用 start() 方法才能执行。
public class T {
   public static void main(String[] args) {
     
	 R r = new R("t1");  // 线程1
	 r.start();
	 
	 R r1 = new R("t2");  // 线程2
	 r1.start();
   }   
}

class R implements Runnable {
	
	String name;
	
	// 构造函数接收线程名
	R(String n){  
		name = n;
	}
	
	public void run(){
		try{
			for(int i = 100; i > 0; i--){
				System.out.println(name);
				Thread.sleep(50);   // 睡眠，使用这个必须要捕获异常
			}
		}catch(Exception e){
			System.out.println("异常");
		}
	}
	
	public void start(){
		Thread t = new Thread(this);   // 创建线程
		t.start();
	}
}

2、通过继承Thread来创建线程：
继承类必须重写 run() 方法，该方法是新线程的入口点。必须调用 start() 方法才能执行。
该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例

实例：将上面代码的class R implements Runnable改为class R extends Thread即可，或改为如下：
public class T {
   public static void main(String args[]) {
	 R t = new R();
	 t.setName("t1111");  // 设置名称
	 t.start();
   }   
}

class R extends Thread {
	
	// 构造函数接收线程名
	R(){  
		Thread t = new Thread(this);  // 创建线程
		t.start();
	}
	 
	public void run(){	
		for(int i = 100; i > 0; i--){
			System.out.println(this.getName());  // 获取名称
		}
	}
}

Thread类的一些重要方法：
是被 Thread 对象调用的

public void start()
使该线程开始执行；Java 虚拟机调用该线程的 run 方法。

public void run()
如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。

public final void setName(String name)  改变线程名称，使之与参数 name 相同。

public final void setPriority(int priority)  更改线程的优先级。

public final void setDaemon(boolean on)  将该线程标记为守护线程或用户线程。

public final void join(long millisec)   等待该线程终止的时间最长为 millis 毫秒。

public void interrupt()  中断线程。

public final boolean isAlive()    测试线程是否处于活动状态。

Thread 类的静态方法。

public static void yield()
暂停当前正在执行的线程对象，并执行其他线程。

public static void sleep(long millisec)
在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。

public static boolean holdsLock(Object x)
当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。

public static Thread currentThread()
返回对当前正在执行的线程对象的引用。

public static void dumpStack()
将当前线程的堆栈跟踪打印至标准错误流。


3、通过 Callable 和 Future 创建线程:
1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。

2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。

3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。

4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。

注意：
如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了
创建了太多的线程，CPU 花费在上下文切换的开销时间将多于执行程序的时间


Java Lambda 表达式：
Java 8 新特性
Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。
Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。
使用 Lambda 表达式可以使代码变的更加简洁紧凑。

语法格式：
(parameters) -> expression
或
(parameters) ->{ statements; }

特征：
可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。
可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。
可选的大括号：如果主体包含了一个语句，就不需要使用大括号。
可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。

注意：
Lambda 表达式主要用来定义行内执行的方法类型接
 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。
lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）

变量作用域：
lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内
部修改定义在域外的局部变量，否则会编译错误


Java 8 方法引用：
List<String> names = new ArrayList();
      names.add("Baidu");
      names.add("Sina");
      names.forEach(System.out::println);
输出：
Baidu
Sina


Java 8 函数式接口:


Java 8 日期时间 API
import java.time.*;

LocalDateTime.now();   日期时间
LocalDateTime.now().toLocalDate();   日期，Time输出时间


连接mysql：
Java 使用 JDBC 连接 MySQL 数据库
下载对应mysql数据库版本jar包，放入jdk8\jre\lib\ext下

1、打开链接选择对应数据库版本：http://dev.mysql.com/downloads/connector/j/
2、选择：Platform Independent，下载：mysql-connector-java-5.1.47.tar.gz，只有几M大小
3、解压后得到 jar库文件，将mysql-connector-java-5.1.47-bin.jar放入jdk8\jre\lib\ext下，
然后在对应的项目中导入该库文件。

代码：
import java.sql.*;  // 导入相关

public class M {
    static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";
    // static final String DB_URL = "jdbc:mysql://localhost:3306/数据库名?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC";	   
    static final String DB_URL = "jdbc:mysql://localhost:3306/数据库名";  // MySQL8.0一下版本使用这个
    static final String USER = "root";  // 用户名
    static final String PASS = "1234";  // 密码
 
   public static void main(String[] args) {    
        try{          
            Class.forName(JDBC_DRIVER);   // 注册 JDBC 驱动       
            Connection conn = DriverManager.getConnection(DB_URL,USER,PASS);   // 打开链接           
            
            Statement stmt = conn.createStatement();  // 执行查询
            ResultSet rs = stmt.executeQuery("SELECT * FROM admin");  			
            
            while(rs.next()){
	int id = rs.getInt("id");  // 根据类型获取数据：rs.getXxx("字段")，id为数据库字段名
	String name = rs.getString("name");
            }

           // 关闭		
           rs.close();
           stmt.close();
           conn.close();

        } catch(Exception e){
	  System.out.println(e);
       }
   }
}

JavaBean：
一种Java语言写成的可重用组件
符合如下标准：
1、类是公共的
2、有一个无参的公共的构造器
3、有属性，且有对应的get、set方法






