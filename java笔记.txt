java是强类型语言

hello world
创建文件Hello.java，写入

/**
 文档注释
*/
public class Hello {
	
	/**
 	 这个方法用来......
	@author 作者
	@version 版本
	@param 参数字符串列表
	@return 返回String
	*/
	public static void main(String[] args){
		System.out.println("hello world");  // println中是小写的L而不是大写的i
	}
}

/*
  多行注释
*/

javadoc从包、公有类与接口、公有的和受保护的构造器及方法、公有的和受保护的域中抽取文档注释信息

注释中出现\u会转译，编译会报错: // 这是\u注释

可以链式编程

javax 表示Java扩展包

javac Hello.java     编译，成字节码得到类名的文件Hello.class，内部使用了其他类时会自动编译对应的类文件
javac He*.java                                  使用通配符
javac -encoding utf-8 h.java             指定编码格式
java Hello                                        运行，后面不用加后缀名

命名规则：字母、数字、下划线、$，不能数字开头，不能含有空格

一个文件可以多个class，但只能有一个public class
------------------------------------------------------------------------------
关键字：
abstract
表明类或者成员方法具有抽象属性
assert
断言，用来进行程序调试
boolean
基本数据类型之一，声明布尔类型的关键字
break
提前跳出一个块
byte
基本数据类型之一，字节类型
case
用在switch语句之中，表示其中的一个分支
catch
用在异常处理中，用来捕捉异常
char
基本数据类型之一，字符类型
class
声明一个类
const
保留关键字，没有具体含义
continue
回到一个块的开始处
default
默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现
do
用在do-while循环结构中
double
基本数据类型之一，双精度浮点数类型
else
用在条件语句中，表明当条件不成立时的分支
enum
枚举
extends
表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口
final
用来说明最终属性，表明一个类不能派生出子类（不能继承），或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量
finally
用于处理异常情况，用来声明一个基本肯定会被执行到的语句块
float
基本数据类型之一，单精度浮点数类型
for
一种循环结构的引导词
goto
保留关键字，没有具体含义
if
条件语句的引导词
implements
表明一个类实现了给定的接口
import
表明要访问指定的类或包
instanceof
用来测试一个对象是否是指定类型的实例对象
int
基本数据类型之一，整数类型
interface
接口
long
基本数据类型之一，长整数类型
native
用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的
new
用来创建新实例对象
package
包
private
一种访问控制方式：私用模式
protected
一种访问控制方式：保护模式
public
一种访问控制方式：共用模式
return
从成员方法中返回数据
short
基本数据类型之一,短整数类型
static
表明具有静态属性
strictfp
用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范
super
表明当前对象的父类型的引用或者父类型的构造方法
switch
分支语句结构的引导词
synchronized
表明一段代码需要同步执行
this
指向当前实例对象的引用
throw
抛出一个异常
throws
声明在当前定义的成员方法中所有需要抛出的异常
transient
声明不用序列化的成员域
try
尝试一个可能抛出异常的程序块
void
声明当前成员方法没有返回值
volatile
表明两个或者多个变量必须同步地发生变化
while
用在循环结构中
----------------------------------------------------------------------------
变量：
先声明，后使用：类型，名字，值
赋值后才能使用变量，作用域在{ }内，同一个作用域不能声明两个同名的变量

数据类型：八种
基本数据类型：数值（整型：byte, short, int, long; 浮点型：float,double）、字符型(char)、布尔(boolean)
引用数据类型：类（class）、接口（interface）、数组（[array]）

byte：1字节=8bit    -128~127
short：2字节           -2^15~2^15-1
***int：4字节           -2^31~2^31-1(约21亿)
long：8字节            -2^63~2^63-1             声明时需要加“l”或“L”，long num = 22443243L;

单精度float：4字节             -3.403e38~3.403e38          float类型定义时要加“f”或“F”
双精度double：8字节          -1.798e308~1.798e308，两倍的float

char(1字符=2字节)    通常使用单引号''，只能写一个字符            char c = 'a';      不能char c = 'ab';
'\n', '\u0043'   都是一个字符

整型和布尔型不能相互转换，if(0){  }  将会编译报错

final int XXX;             // 使用find关键字定义常量，一旦赋值不能更改
static final int XXX;   //  一个类常量


0x十六进制，0开头八进制，0b二进制
java7开始可以使用：int n = 1_000_000;  可以加下划线

自动类型提升：
使用大范围接收小范围:
byte、char、short----->int----->long---->float---->double
int num = byte + int       应该使用int类型接受或更大范围的类型
 int n = 'a' + 1;                98，a的ASCII码为97
char c = 'a' + 1;               b
byte、char、short运算至少要用int接收

强制类型转换：
double d = 12.9；
int i = (int)d;              强转为int类型，结果为12，大变小会损失精度
long l = 2323233；    后面没加“l”“L”，会变成int，超过整型范围编译报错
float后面一点要加“F”“f”，不然编译报错

String属于引用数据类型：String s = "djfkd";   // 字符串，使用双引号，char使用单引号且内容不能为空
String可以何8中数据类型做连接运算“+”，结果是String类型
String s = 3.5f + "";         3.5

在将父类转换成子类之前，应该使用instanceof进行检查
if (o instanceof DemoClass) {
	DemoClass o = (DemoClass) o;  // 尽量少用
}

只能在继承层次内进行类型转换

null instanceof Object  ==> false

String s = String.valueOf(2);   数字转为字符串

原码取反得反码加1得补码，符号位除外
计算机底层都以补码保存数据

public static strictfp void main(String[] args){}    strictfp关键字，在main方法或类中将使用严格的浮点计算

byte s = 1;
s += 2;                      不会改变变量本身的类型
s = (byte)(s + 2);        需要转换类型，不然编译出错，数字默认int类型

浮点数除0会得到无穷大或NaN：3.14/0 得到Infinity，整数除0运行报错，编译不报错

instanceof：是 Java 的保留关键字，作用是测试它左边的对象是否是它右边的类（或接口）的实例，返回 boolean 类型

负数求余得负数

逻辑运算：&&、||、!，前两个是短路运算
无短路：逻辑与&（两个都为真则真）、逻辑或|（有一个真则真）、逻辑异或^(不同为true)
位运算符是直接对整数的二进制的运算：左移<<乘2、>>除2、无符号右移>>>全部补0

交换两个数的位置：
1、定义第三个变量或如下
2、
num1 = num1 + num2;
num2 = num1 - num2;
num1 = num1 - num2
3、异或
num1 = num1 ^ num2;
num2 = num1 ^ num2;
num1 = numq ^ num2;


斐波那契数列：
if ((n == 0) || (n == 1))
            return number;
        else
            return fibonacci(n - 1) + fibonacci(n - 2);

System.out.println();
println() 是一个方法。
System 是系统类。
out 是标准输出对象。
定义方法用小驼峰命名法，如：myName, 下划线也行my_name

System.gc();   //调用Java垃圾收集器

修饰符 返回值类型 方法名(参数类型 参数名){                    头
    ...
    方法体                                                                      体
    ...
    return 返回值;
}
如：public static int age(int birthday){...}

可变参数:
必须再最后一个位置，且只能有一个可变参数
fun(String s, int ... n) { }          长度：nums.length，js也有这种，int... n 等价于int[ ] n，但后者需要new数组
传参
fun("str", 1, 2, 3);   
fun("str", new double[ ]{1, 2, 3});

finalize() 方法
Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。
例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。
protected void finalize()
{
   // 在这里终结代码
}
关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。
当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。


命令行参数传入main方法的args：java T 参数1 参数2 

 三元运算：int num = num1 > num2 ? num1 : num2;
效率比if-else高

方法传参：
1、按值调用（值的拷贝），java使用按值调用
2、按引用调用（地址）

static：
用来修饰：属性，方法，代码块，内部类。
每个类只有一个静态域，属于类，所有实例对象都共享这个静态域（相当于全局），静态域属于类。

在内存中类只有一份，实例对象可以有无数份

静态变量：
也称类变量或类属性，随着类的加载而加载。在内存中只有一份
调用：类.静态变量，对象.静态变量
static int a;  // 静态变量，类属性
public static final int a = 1;    // final跟static不分先后
public final static int b = 2;

静态方法：
类方法，内部只能调用静态方法跟静态属性，不能使用this、super
工具类的方法一般定义成静态方法
调用：类.静态方法()
public static void fun(){ // 内部一般使用静态属性  }

例如，计算器
     private static final int a = 0;   // 静态常量，用的比较多，静态变量少：private static int a；
     public M(){    // 构造函数
	a++;  // 每new一个对象，a就加1
    }
静态方法没有this参数，不能使用实例属性、方法，可以访问静态变量
建议使用"类名.静态方法()"调用静态方法，"对象.静态方法()"也能调用

实现单例模式：
饿汉式：
1、私有化类的构造器：private A(){ }
2、在内部创建类的对象，此对象也声明为static的：private static A = new A();
3、提供公共的静态方法返回类的对象: public static A getXxx(){ return A; }

懒汉式：
1、私有化类的构造器：private A(){ }
2、在内部声明类的对象，此对象也声明为static的：private static A = null；
3、提供公共的静态方法返回类的对象，判断是否已经创建过 
    public static A getXxx(){ 
        if(A == null){ 
            A = new A();    // 第一次new时 
        }
        return A;
    }

饿汉式：一开始就造好对象，线程安全的
懒汉式：什么时候用，什么时候创建，线程不安全的，当同时new两个实例，同时创建对象
             解决线程安全问题加上synchronized关键字：public static synchronized A getXxx(){}
             同步监视器就是当前类本身（A.class）

单例设计模式应用场景：
网站的计数器
应用程序日志应用
数据库连接池
读取配置文件的类
Application
window的任务管理器、回收站


代码块：
或初始化块
1、用来初始化类，对象
2、代码块要修饰的话，只能用static修饰
3、分为静态代码块跟非静态代码块
static{
    // 静态代码块
    // 可以有输出语句，随着类的加载而执行，只执行一次，多个按先后顺序执行，优先于非静态代码块
    // 只能调用非静态结构（静态属性，静态方法）
}

{
    // 非静态代码块
    // 随着对象的创建而执行，new的时候执行，每new一次执行一次，多个按先后顺序执行
}

总结：由父及子，静态先行


从键盘获取输入：Scanner类
import java.util.Scanner;
Scanner scan = new Scanner(System.in);
int num = scan.nextInt();       接收int类型，nextFloat(), nextDouble(), nextLine()

Math.random();   随机数返回[0,1)区间double类型
任意区间整数公式：[min, max] ==> (int)(Match.random() * (max - min + 1) + min)

for循环的初始化部分声明的变量，其作用范围在整个循环。
但循环体内声明的变量其适用范围是从它声明到循环体结束
for(int i = 0;;){}
i不能在外面使用

流程控制：
只有一行可以省略花括号，不建议这样

if(表达式){                             if-else结构
}else if(表达式){
}else{ 
}

switch(1){            // switch-case结构执行效率比if-else高，根据表达式值匹配常量找到入口
   case 常量1:       // 表达式的值的类型只能是6种：byte、short、char、int、枚举、String
      语句;
      break;     // break可选
   case:          // 多个case相同，可以合并
   case "1":    // 编译报错，String无法转换为int
   case:
      语句;
      break;
   default:      // default可选，放在哪里都行，一般在最后
      语句;
}
case后常量会尝试跟switch表达式的类型进行转换，有些类型不能相互转换，会编译报错

循环：
1、for(int i=0; i<10; i++){ }
2、while( ){ }
3、do{ }while( )
4、for(int i : intArr){ }  增强for循环

for(; ;) <==> while(true)

break 跳出当前层循环
continue 结束本次循环，开始下一次
return；   能结束多层循环

标签可以指定跳出的循环，标签可以使用在任何地方，如if语句
my_label:for(){
   for(){ break my_label; }  // 跳出指定标识的一层循环，continue则结束指定标识处本次循环
}

System.currentTimeMillis();    1970年1月1日 00：00：00 至今的毫秒数

衡量代码的优劣：正确性、可读性、健壮性(鲁棒性)、高效率(时间复杂度）与低存储(空间复杂度）


数组：
相同类型数据按一定顺序排列的集合，数组是引用数据类型，元素也可以是应用数据类型
一旦初始化完成，长度就确定了，长度一旦确定，就不能更改

使用：
声明、分配空间、赋值
1、类型[] 名称 = new 类型[]{1, 2, 3, 4 };                          声明并初始化，静态初始化
2、类型[] 名称 = new 类型[20];                                      动态初始化 ，***标准写法***
3、类型[] 名称 = {1, 2, 3};                              声明并初始化，叫类型推断

二维数组声明方式：
int[ ][ ] arr = new int[3][4];    // int[ ][ ]{ {1, 2, 3}, {4 , 5, 6} }    
int[ ][ ] arr = new int[3][ ];     // 也可以这样  
int arr[ ][ ] = new int[3][4]; 
int[ ] arr[ ] = new int[3][4]; 
int[][] arr = { {1, 2, 3}, {4 , 5, 6} } ;       类型推断，省略new

int[] arr = {1, 2, 3};             
arr.length;                   属性，获取数组长度
arr[2].length;               多维数组第三维长度

二维数组遍历：
for（int i = 0; i < arr.length; i++）{
    for(int j = 0; j < arr[i].length; j++){
        System.out.println(arr[i][j]);
    }
}

数组反转：
第一个与最后一个交互，第二个与倒数第二个交换。。。，时间效率高
for (i = 0; i < n / 2; i++) {
            t = a[i];
            a[i] = a[n - i - 1];
            a[n - i - 1] = t;
}

查找重复元素：
 int count=0;
        for(int j=0;j<a.length;j++) {
            for(int k =j+1;k<a.length;k++) {
                if(a[j]==a[k]) {
                    count++;
                }
            }
            if(count==1)
               System.out.println( "重复元素 : " +  a[j] );
            count = 0;
        }

数组默认初始化值：
整型byte、short、int、long         0
浮点型float、double                    0.0
char类型                                     '\u0000', cha[1]==0
布尔                                            false
引用数据类型String                       null, 不是"null"
二维数组的第一层默认值地址，最后一层跟一维数组一样
int[ ][ ] arr = new int[3][ ];   // arr[0] 为null，任何类型都是null，因为是引用类型(引用地址)

for(int num: myList){}       迭代循环，num是数组元素, 类似python for ... in ...

数组的内存解析：
堆（heap）：存放局部变量
栈（stack）：存放new出来的结构（对象，数组），栈存放16进制地址值 

数组工具类：Arrays
Arrays.equals(arr1, arr2)        判断两个数组是否相等
toString(arr1)                       输出数组信息
fill(arr1, "值")                       将指定数组填充到数组中，全部填充为同一个"值"
sort(arr1)                            数组排序
binarySearch(arr1， 3)        排序后的数组进行二分查找指定值：3，返回索引
Arrays.asList(arr)；              数组转集合

十大排序算法：
选择排序： 直接选择排序、堆排序
交换排序： 冒泡排序、快速排序 O(nlog(n))，内部排序最快的是快速排序
插入排序：直接插入排序、折半插入排序、shell排序
归并排序
桶式排序
基数排序

字符串类加效率比较低，使用类：StringBuilder b = new StringBuilder();  b.append("xx");
    

垃圾回收机制：引用计数
排序算法的稳定性：a、b两个值相等，排序后a、b的先后次序不变，则是稳定的


基本数据类型赋值是复制，再创建一个，传参传真实值
引用数据类型是地址传递，都指向同一个，方法传参传地址


public class T {
	public static void main(String[] args) {
		T t = new T();    // 可以这样使用
	}
}

char[] arr = new char[]{'a', 'b'};
System.out.print(arr);   // 输出：ab，而不是地址值，其他的是输出地址值


jdk8 日期：
java.time，java.time.format
LocalDate、LocalTime、LocalDateTime 
格式：
2021-10-18
20:53:40.424
2021-10-18T20:53:40.424

三个类都有的方法
now();                                     // 当前时间，日期
of(2020, 12, 30, 12, 33, 55);     // 转换年月日时分秒，2020-12-30T12:33:55
now().getXxx();         // 获取
now().withXxx();       // 设置，内部定义为不可变的
now().plusXxx(3)；  // 加
now().minusXxx();   // 减

格式与解析日期时间DateTimeFormatter类：
DateTimeFormatter dd = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");  // 最常用的实例化方式
String s = d.format(LocalDateTime.now());  // 日期 --> 字符串  "2021-10-18 11:11:27"，格式化
TemporalAccessor a = dd.parse("2021-10-18T23:01:37.923")； // 字符串-->日期，解析


Instant类：
Instant i = Instant.now();
i.now();  // 东八区日期时间，不是我们的
i.toEpochMilli()；// 1970-1-1  到现在毫秒数
Instant.ofEpochMilli(1634566294733l);  // 转换为2021-10-18T14:11:34.733Z
OffsetDateTime a = i.atOffset(ZoneOffset.ofHours(8);  // 要偏移8小时, 2021-10-18T22:10:45.011+08:00


import static java.lang.Math.*;    导入指定包下类或接口的静态结构、属性、方法
PI、E、......

int i = 1;
double d = 3.14;
i += 3.14;   将会发生强制类型转换：(int)(x + 3.14)


比较器（对象排序）：
java.lange.Comparable接口、java.util.Camparator接口，对象比较
Comparable：
自然排序
重写compareTo方法，比较属性，如价格，大于返回正数，等于返回0，小于返回负数
public int compareTo(Object o){
    if(o instanceof Goods){
        Goods goods = (Goods) o;
        if(this.价格 > goods.价格) return 1;
        if(this.价格 < goods.价格) return -1;
        if(this.价格 == goods.价格){ 
            return -this.评论.compareTo(goods.评论);  // 相同情况下，按评论比较排序
        }
    }
    throw new RuntimeException("数据类型不一样，不可比较");
}

Comparator:
定制排序
重写compare方法，大于返回正整数，等于返回0，小于返回负数
public int compare(Object o1, Object o2){
    if (o1 instanceof Goods && o2 instanceof Goods){  // 按照产品名称从低到高排序，再按照价格从高到底排序
        Goods g1 = (Goods) o1;  // 强转
        Goods g2 = (Goods) o2;
        if(g1.getName().equals(g2.getName))
            return -Double.compare(g1.getPrice(), g2.getPrice())； // 调用Double的compare方法，比较价格
        else
            return g1.getName().comparTo(g2.getName());
    }
    throw new RuntimeException("数据类型不一样，不可比较");
}


其他常用类使用：System、Math、BigInteger、BigDecimal
System类：
err    错误输出流
in     输入流
out   输出流
exit(0)    退出程序，0正常推出
currentTimeMillis()     返回当前计算机时间，1970-01-01
gc()       请求系统进行垃圾回收
getProperty(String Key)   获取系统属性key的对应值

Math数学类：
abs
sqrt
pow(a, b)    a的b次幂  
max(x, y)
min(x, y)
random      0.0到1.0之间随机数
round(double num)    四舍五入

BigInteger、BigDecimal类：
java.math包下
BigInteger可以表示不可变的任意精度的整数
BigDecima任意精度的有符号十进制定点数，商业计算中，要求精度比较高的，用这个类，小数点后几十位的


使用正则：
import java.util.regex.*;         导入相关类：Pattern, Matcher, PatternSyntaxException

boolean a = Pattern.matches(".*abc.*", "adjfabcdjfkd");      true, \\d+ 匹配多个数字，两个 \\ 代表其他语言中的一个 \
System.out.println("\\");       // 输出一个\，两个斜杠输出一个斜杠


Java 流(Stream)、文件(File)和IO：
Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。
Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。
一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。

有很多方法可以产生流
Stream<String> s = Stream.of("a", "b", "c");    // s是一个流
s.filter(i -> i.equals("b"));     // 过滤，返回符合条件的新流
s.map(i -> i + "x");             // lambda应用于每个元素，返回新流
s.map(i -> i + "x").limit(5);  // 前五个，不5个取全部，相反的skip(5)则跳过前五个
s.distinct();                        // 去重后的
Stream.concat(非无限流，流);  // 拼接两个流  
s.forEach(System.out::println);  // 输出每个元素
String[] arr = s.toArray(String[]::new);  // 默认返回Object[ ]，使用String[ ]::new，转换为String[ ]

输入输出流：
一般是文件内容的读写
抽象类：InputStream, OutputStream

InputStream in = new FileInputStream("aa.txt");                 打开读取
OutputStream out = new FileOutputStream("test.txt");       打开写入
......
try{                                                                                   必须捕获异常
    byte b[ ] = {1,2,3,4,5};
    OutputStream os = new FileOutputStream("bb.txt");    打开写入到文件，没有则创建文件
    os.write(b);                                                                   写入字节数组
    os.close();                                                                     关闭
			 
    InputStream in = new FileInputStream("bb.txt");            打开读取到内存
    xxx xx = in.read();                                                           读入字节数组，返回读入的字节数                         
    in.close();

    // 1、创建文件并写入，指定编码格式
   PrintWriter p = new PrintWriter("a.txt", "utf-8");   
   p.write("登机口附近124dfkdjf\n");   // 写入
   p.print("aa ");   // 写入
   p.println(123);
   p.close();

    // 2、创建文件写入
   BufferedWriter out = new BufferedWriter(new FileWriter("aa.txt", true));  // true为追加
   out.write("1223xxx地方");   // 写入
   out.close();                        // 关闭

   // 读取
   BufferedReader in = new BufferedReader(new FileReader("a.txt"));  
   in.readLine();     // 读取，文件结束返回null
   in.close();

}catch(Exception e){
    System.out.println(e+"异常");
}

对象输入输出流：
try {
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("a.txt"));  // 输出流
            out.writeObject(new A());  // 写入文件

            ObjectInputStream in = new ObjectInputStream(new FileInputStream("a.txt"));  // 输入流
            A a = ( A ) in.readObject();  // 读出文件，以被写入的顺序读出
            System.out.println(a.i);

            in.close();
            out.close();

        }catch (Exception e){ }

class A implements Serializable {   // 实现Serializable接口（序列化）
    transient int i = 1;  // 关键字transient表示此域不可被序列化，会跳过
}

文件操作：
import java.io.*;   
public static void main(String args[]){
                  try{    
 		 

		  File f = new File("a.txt");
                                  f.length();     // 文件大小（字节）
		  f.exists()；   // 是否存在 
   		  f.isFile()；   //  是否是文件
		  f.delete();   // 删除
 		  f.renameTo(new File("bbb.txt"));  // 重命名
		  f.lastModified()；// 文件最后修改时间

		// 创建文件
		File f = new File("xxx.txt");
		f.createNewFile();  

		File.createTempFile("a", ".txt", new File("E:/"));  // 在指定目录下创建文件 "E:/a.txt"

		System.getProperty("user.dir");    // 返回当前工作目录

		// 文件内容复制到另一个文件
		InputStream in = new FileInputStream(new File("srcfile"));
        		OutputStream out = new FileOutputStream(new File("destnfile"));
        		byte[] buf = new byte[1024];
        		int len;
        		while ((len = in.read(buf)) > 0) {  // 文件的字节大小
            		    out.write(buf, 0, len);
        		}
        		in.close();
        		out.close();
	   }catch(IOException e){
		   System.out.print(e);   //  必须要捕获异常
	   }
   }



java.lang包中的类不需要import导入，其他需要


读取控制台输入：
Scanner类 + System.in

import java.util.*;

Scanner scan = new Scanner(System.in); 
if(scan.hasNext()){                 // 判断是否还有输入的数据或是否是指定数据类型，hasNextXxx，如hasNextLine、hasNextInt ......
    String s = scan.next();       // 接收输入值，第一个空格结束，nextLine()以回车结束，nextInt，nextFloat
}
System.out.println(str1);
scan.close();   // 关闭	

next():
1、一定要读取到有效字符后才可以结束输入。
2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。
3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。
next() 不能得到带有空格的字符串。

nextLine()：
1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。
2、可以获得空白。

Console类适用于从控制台读取密码

块作用域：
包含在{ }内，不能再嵌套的块中定义两个同名的变量：{ int n;  { int n; } }，编译报错


异常：
java.lang.Throwable
语法错误和逻辑错误不是异常

异常处理机制：
1、try-catch-finally
2、throws

try{ 
}catch(异常类型 变量){ 
}catch(Exception e){ 
}finally{ }    最后都会执行，一定会执行的，即使其他地方有return语句，finally里面有return，则其他地方的return不会执行   

可以嵌套

在try中声明的变量，在外面不能使用

多个catch块中的异常出现继承关系，父类异常catch块放在最下面（Exception）

throws/throw:
thorws + 异常类型，写在方法声明处，指明此方法执行时可能抛出的异常类型，一旦方法体执行时，出现异常，仍会在
异常代码处生成一个异常类对象，此对象满足throws后异常类型时，就会被抛出，异常后面的代码不会再执行。
throw  主动抛出异常

try(Scanner in = new .....; PrinWriter out = new .....){   // try可以带资源(打开文件)，始终会关闭资源，类似python的with open......
    method();   // 捕获该方法throws可能抛出的异常    
}catch(RemoteException e){

}catch(Exception e){       // 可以合并catch语句   catch(类型1 | 类型2 e){ }  e变为final类型，不能赋值
    // 将原始异常设置为新异常的“原因”，使用语句 Throwable e = se.getCause(); 重写得到原始异常
    Throwable se = new Exception("错误信息")；   
    se.initCause(e);
    throw se;
}

public void method() throws 异常类型1, 异常类型2... { 
	try {
	    throw new Exception("我的异常");      // 主动抛出异常，必须放在try内，或再方法中声明throws
	 }catch(Exception e) {                            // 捕获异常
	    System.out.println(e);
                   e.getMessage();                                // 输出信息
	    e.printStackTrace();                           // 获取异常堆栈信息
	   }finally {
	   // 最后执行，如果finally中有return语句，则会覆盖原始的返回值
	}
}    

抛：
throw

抓：
try-catch-finally  真正的处理的异常
throws  只是将异常抛给了方法的调用者，并没有真正的将异常处理

子类重写的方法抛出的异常类型不能大于父类被重写的方法抛出的异常类型
父类方法没有throws抛出异常类型，子类也不能抛出
执行方法a中，先后又调用了另外几个方法，这几个方法是递进关系的，则建议这几个方法使用throws方式进行处理，
而执行方法a可以考虑使用try-catch-finally方式进行处理。

检查性异常：
最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，
这些异常在编译时不能被简单地忽略。

运行时异常： 
运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。

错误： 
错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。

声明自定义异常：
所有异常都必须是 Throwable 的子类。
1、检查性异常类，需要继承 Exception 类。运行时异常类，需要继承 RuntimeException 类。
2、提供全局常量serialVersionUID
3、提供重载构造器，一个默认构造器，一个带有详细描述信息的构造器
public class MyException extends Exception {
    static final long serialVersionUID = -7743294724883748347L;

    publice MyException(){ }   // 默认构造器

    publice MyException(String msg){   // 有详细描述信息的构造器
        super(msg);
    }
}
publice void method() throws MyException{    // 使用throws指定可能抛出的异常
    throw new MyException("这是异常信息");     // 主动抛出自定义异常
}

异常体系结构：
java.lang.Throwable
    java.lang.Error   一般不编写针对性的代码进行处理
    java.lang.Exception  可以进行异常处理
        编译时异常（checked）  
            IOException
                   FileNotFoundException
            ClassNotFoundException
       运行时异常（unchecked，RuntimeException）  
           NullPointerException
           ArrayIndexOutOfBoundsException
           ClassCastException
           NumberFormatException
           InputMismatchException
           ArithmeticException

使用异常机制的技巧：
1、利用异常层次结构
 不要只抛出RuntimeException异常，应该寻找更加适当的子类或创建字节的异常类
 不要只捕获Thowable异常
2、异常处理不能代替简单的测试
3、不要过分的细化异常
4、不要压制异常
5、早抛出，晚捕获

使用断言assert：
断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测语句将会被自动移走。
断言检查只用于开发和测试阶段。应该用于在测试阶段确定程序内部的错误位置。
关键字：assert，两种形式
1、assert 条件;                 // 结果为false，则抛出AssertionError异常
2、assert 条件：表达式；  // false，则将表达式传入AssertionError构造器，并转换成一个消息字符串
断言默认关闭，启用：java -ea MyApp，-da禁用断言

记录日志:
import java.util.logging.Logger;

Logger.getGlobal().info("xxx");                   // 打印日志信息，级别：info
Logger.getGlobal().setLevel(Level.OFF);     // 关闭日志，在main方法使用将取消所有日志

企业级日志：
private static final Logger log = Logger.getLogger("com.aa.bb");   通常使用static，不会被垃圾回收
log.setLever(Lever.FINE);       // 设置日志级别，Lever.ALL开启所有级别的记录
log.info("xxx");                     // 输出info级别日志信息
log.log(Level.FINE, "xxx");     // 指定级别

日志级别：
1、SERVER            最低，默认记录前三个
2、WARNING
3、INFO               
4、CONFIG
5、FINE
6、FINER
7、FINEST         最高级别

try{ 
}catch(Exception e){
    Logger.getLogger("com.aa.bb").log(Level.INFO, "xxxx", e);     // 在异常中使用
}

编辑配置：
默认在日志配置文件：jre/lib/logging.properties
可以使用自己的配置文件，需要修改java.util.logging.config.file中配置文件的存储位置
然后命令启动：java -Djava.util.logging.config.file=configFile MainClass


面向对象OOP：
只有单继承
封装、继承、多态

属性 = 成员变量 = field = 域、字段

修饰符：
1、访问修饰符
2、非访问修饰符
修饰符用来定义类、方法或者变量，通常放在语句的最前端
局部变量不能使用访问修饰符

访问修饰符：
使用访问控制符来保护对（类、属性、方法、构造器）的访问
Java 支持 4 种不同的访问权限，从小到大：
1、private : 在本类内可见。使用对象：变量、方法。 注意：不能修饰外部类
2、缺省 (即默认，什么也不写）: 在同一包内可见。使用对象：类、接口、变量、方法。
3、protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰外部类
4、public : 对所有类可见。使用对象：类、接口、变量、方法

类（class）只能用public或缺省修饰

非访问修饰符：
1、static  修饰符，用来修饰类方法和类变量。
2、final   修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，
              修饰的变量为常量，是不可修改的。
3、abstract              修饰符，用来创建抽象类和抽象方法。
4、synchronized 和 volatile      修饰符，主要用于线程的编程。volatile 修饰符volatile修饰的成员变量在每次被线程访问时，
                                               都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。
                                              这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个 volatile 对象引用可能是 null。
                                              synchronized关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。
5、transient             修饰符，序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量，不会持久化保存
                              该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

局部变量没有默认初始化值，赋值后才能使用，不然编译报错
局部变量加载到栈空间，属性（非static）加载到堆空间

方法：
访问修饰符 返回类型 方法名( 参数类型 变量 ){  }
public void  log( String num ){  }

方法里不能再定义方法

匿名对象：不赋值，直接new，new MyClass().方法名()，使用：obj.fun( new MyClass() )
匿名数组：new int[ ]{1, 2, 3, 4}; 

构造方法或构造器：
任何一个类都有构造器
当一个对象被创建时候（new），构造方法用来初始化该对象。构造方法和它所在类的名字相同，构造方法没有返回值。
通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。
不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，
默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。
一旦你定义了自己的构造方法，默认构造方法就会失效。
可以有一个以上的构造方法。
构造方法伴随new操作一起调用。

class MyClass {
  public MyClass() { }                // 构造器，默认是空参构造器，默认权限修饰符跟随class
  public MyClass(int i){ }           // 构造器重载，重载后一定要有一个空参构造器
 }

自定义了构造器后，系统不会提供默认的无参构造器

java的所有对象都是在堆中构造的

对象数组：
MyClass[ ] my = MyClass[20];    // 数组元素为对象

MyClass a;  // 声明一个这个类的变量

同一个目录下两个文件，可以直接new另一个文件的类
test目录
   Main.java
   Test.java

类设计的技巧：
一定要保证数据私有
一定要对数据初始化
不要在类中使用过多的基本类型：int，String。。。。
不是所有的域都需要独立的域访问器和域更改器：getxx、setxx
将职责过多的类进行分解
类名和方法名要能体现他们的职责
优先使用不可变的类

继承：
父类（超类、基类）
子类（派生类、孩子类）

继承能获取符类的所有属性跟方法，因为封装性的影响，子类使用不了符类私有的东西，但确实获取了私有的结构

父类型数组可以转换成子类型数组，不需要强制类型转换

所有类的顶层类为Object

public 子类 extends 父类{ }

子类拥有父类非 private 的属性、方法
继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，
当一个类没有继承的两个关键字，则默认继承object

implements：
使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，
可以同时继承多个接口（接口跟接口之间采用逗号分隔）
public interface A {
    public void eat();
    public void sleep();
}
 
public interface B {
    public void show();
}

public class C implements A,B { }      类继承多个接口

super：  
父类，显示的调用父类的方法或属性，子类可以使用super来访问父类的私有域，super.私有方法()、属性

super()必须声明在子类构造器首行
构造器的首行没有显示的声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类种空参的构造器super()
在构造器中，“this(形参列表)”或“super(形参列表)”不能同时出现
在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”，调用父类的构造器

this：     
当前对象，类似python shelf
在其他方法里面调用构造器：this(参数);
int age;
public fun(int age){
	this(age);  // 调用构造器，必须在首行，调用同一个类的***另一个***构造器
	this.age = age;
}    

初始化块：
在一对花括号内，先运行初始化块才运行构造器，建议将块放在定义变量的后面
int a;
int b;
{           // 实例域初始化
  a = 1;
  b = 2;
}

static{   // 静态域初始化
  ...
}

变量默认值：数值型0、布尔型false、对象型null

import java.util.Random;
new Random().nextInt(3);  // 返回一个0到n-1之间的随机整数

继承的设计技巧：
1、将公共操作和域放在超类
2、不要使用受保护的域
3、使用继承实现 "is a" 关系
4、除非所有继承的方法都是有意义的，否则不要使用继承
5、在覆盖方法时，不要改变预期的行为
6、使用多态，而非类型信息
7、不要过多的使用反射

final：
最终的
final可以用来修饰：类、方法、变量
final 修饰的类，不能被继承
final 修饰的方法，不能被子类重写         
final 修饰属性或局部变量，不能被修改，即常量，方法的形参定义final，内部不能再修改  
1、public final class 类名 { }
2、public final 返回类型 名称( ){ }
3、final int ABS = 1；// statci final int a = 1; 全局常量

声明为 final 的类，只有方法自动地声明为 final


父类构造方法有参数需要在子类使用super调用，无参数则自动调用


重写（覆盖）：
重写是子类对父类的允许访问的方法的实现过程进行重新编写, *** 返回值 和 形参 ***不能改变。即外壳不变，核心重写！
重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。
重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。
例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法
的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能
抛出 IOException 的子类异常。

重写规则：
方法名跟参数列表必须相同
返回类型与被重写方法的返回类型可以不相同（void除外），但是必须是父类返回值的子类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
返回值是void，则重写也要返回void。
访问权限要大于等于父类方法的访问权限，例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
父类的成员方法只能被它的子类重写。
声明为 final 的方法不能被重写。
声明为 static 的方法不能被重写，但是能够被再次声明。
子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和  的非 final 方法。
重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，
或者比被重写方法声明的更广泛的强制性异常，反之则可以。构造方法不能被重写。

重载(Overload)：
***同一个类内，方法名相同，参数类型不同，或参数顺序不同***
如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；
如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；
就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。
Java编译器根据方法签名判断哪个方法应该被调用。
方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。
重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。

如何确定调用哪个方法：方法的签名（方法名 + 参数列表） 

重载规则:
被重载的方法必须改变参数列表(参数个数或类型不一样)；参数顺序不同也是重载
被重载的方法可以改变返回类型；
被重载的方法可以改变访问修饰符；
被重载的方法可以声明新的或更广的检查异常；
方法能够在同一个类中或者在一个子类中被重载。
无法以返回值类型作为重载函数的区分标准

show(int ... a){} 等于  show(int[ ] b){}    

多态：
多态是同一个行为具有多个不同表现形式或形态的能力。
现实中，比如我们按下 F1 键这个动作：
      如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；
      如果当前在 Word 下弹出的就是 Word 帮助；
      在 Windows 下弹出的就是 Windows 帮助和支持。
同一个事件发生在不同的对象上会产生不同的结果。

代码的通用性

多态的优点
1. 消除类型之间的耦合关系
2. 可替换性
3. 可扩充性
4. 接口性
5. 灵活性
6. 简化性

多态存在的三个必要条件：
继承
重写
父类的引用指向子类对象：Parent p = new Child();

class B extends A
A obj = new B();  // 对象的多态性：父类的引用指向子类的对象
boj.eat();  // 多态的使用：当调用子父类同名同参的方法时，执行的是子类重写父类的方法-----虚拟方法调用

x.eat()
y.eat()
public void fun(Object obj){
    obj.eat();
}
obj.fun(new X);  // x.eat()
obj.fun(new Y);  // y.eat()

传入不同对象，执行两个对象中相同的方法，输出不同，省去了方法重载

多态的使用：虚拟方法调用。
有了对象多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子
类重写父类的方法。
总结：
编译时看左边（A），运行时看右边（B）

对象的多态性只适用于方法，不适用于属性（编译和运行都看左边)

方法调用那一刻才确定要调用的具体方法，动态绑定，就是多态

内存中实际上加载了子类特有的方法跟属性，由于变量声明为父类类型，导致编译时
只能调用父类中声明的方法跟属性。子类特有方法跟属性不能调用。除非强制类型转
换（向下转型：父类--->子类）。B obj = （B）a；


Object类：
obj.getClass();  // 查看创建obj对象的类，obj.getClass().getSuperclass();  获取对象的类的父类
==：基本数据类型比较值，引用类型比较地址

equals()方法:
Object中equals()方法跟==是相同的，都是比较地址，检测两个对象是否相等，相同的引用
String、Date、File、包装类等都重写了Object中的equals()方法，重写后，比较的是两个对象的“实体内容”
是否相同。
我们自定义类如果使用equals()的话,通常也是比较两个对象的“实体内容”是否相同，我们需要重写Object中的
equals()方法。可以参考String.equals()是如何重写的。
idea可以自动调用重写equals()，一般开发使用这种。
重写原则：比较两个对象的实体内容是否相同（name,age.....）。
==符号要保证变量两边数据类型一致。

一个完美的equals示例：
import java.util.Objects;  // 导入
public boolean equals(Object otherObject){          // 重写Object的equals方法
        if(this == otherObject) return true;

        if(otherObject == null) return false;

        if(getClass() != otherObject.getClass()) return false;

        Main other = (Main) otherObject;

        // 基本数据类型用==比较，equals比较对象
        return age == other.age && Objects.equals(file, other.file);
}

如果在子类中重写定义equals，就要在其中包含调用super.equals(other)，如下：
public boolean equals(Object otherObject){          
        if(!super.equals(otherObject) return false;      
        Main other = (Main) otherObject;  

        // 基本数据类型用==比较，equals比较对象
        return name == other.name;
}

Objects.equals(Object a, Object b);  // 两个都为null返回true，其中一个为null返回false，否则返回a.equals(b)

toString()方法：
obj.toString();  // 输出obj的地址，跟System.out.print(obj);一样，String.toString()是重写后的
对象与字符串用+连接起来，自动调用对象的toString方法："" + obj

java中的JUnit单元测试：
1、选中当前工程--右键选择：build path -- add libraries -- JUnit 4 -- 下一步
2、创建java类，进行单元测试，要求：此类是public的、此类提供公共的无参的构造器
3、在此类中声明单元测试方法，要求：是public、没有返回值、没有形参
4、在此单元测试方法上声明注解：@Test，需要导入import org.junit.Test;
5、声明好单元测试方法后，就可以在该方法体内写测试相关的代码了
6、写完后，运行：左键双击单元测试方法名，右键run as -- JUnit Test，红条表示失败，绿条表示成功

包装类：
八种基本数据类型对应的包装类如下：
基本类型	引用类型
boolean	Boolean
byte	Byte
short	Short
int	Integer
long	Long
float	Float     // 前六个派生于Number类
double	Double
char	Character

boolean b；  // 默认值为false
Boolean b；  // 默认值为null

包装类的使用：
基本数据类型、包装类和String类型间的相互转化

基本数据类型--->包装类：
Integer num = new integer("123");  // 或123，字符串中只能有数字
Boolean b = new Boolean(true);  // 字符串不区分大小写，如："tRue"，有其他字符"true123"为false

包装类--->基本数据类型：
调用包装类的xxxValue()
Integer i = new integer(15);
int num = i.intValue();  // 转为基本数据类型，floatValue、doubleValue()......

***JDK 5.0特性："自动装箱" 与“自动拆箱” 互相转换类型
int num = 12；
integer n = num；  // 自动装箱，基本数据类型--->包装类
int num3 = n;         // 自动拆箱，包装类--->基本数据类型

方法形参接受对象类型（Object obj），传参传入基本数据类型（int）
public void method(Object obj){ }
int num = 1;
method(num);  // 自动装箱

基本数据类型、包装类--->String类型：
float num = 1.0f;
String s = num + "";  // 方式一，与空字符串相加能转换类型
String s = String.valueOf(num);  // 方式二，调用String.valueOf()方法转换类型

String类型--->基本数据类型、包装类:
调用包装类的parseXxx()方法
int num = Integer.parseInt("123");   // Float.parseFloat("12.3f");........

面试题：
1、
Object o = true ? new Integer(1) ： new Double(2.0);
o结果为1.0，使用new integer(1)，但编译的时候类型自动提升为double
2、
Object o；
if（true）{
    o = new Integer(1);
}else{
  o = new Double(2.0);;
}
o结果为1，没有自动类型提升
3、
Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.prnt(x == y);  // false，比较地址值

Integer x = 1;
Integer y = 1;
System.out.prnt(x == y);  // true，Integer类内IntegerCache方法中定义了Integer[ ]数组，缓
                                      存了“-128-127”之间的数的数组，使用自动装箱方式可以之间使用
                                     范围内的元素，超出范围则用new，python也有这种

Integer x = 128;
Integer y = 128;
System.out.prnt(x == y);  // false，超出数组范围，使用new


抽象类和抽象方法：
abstract
抽象类：
在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，
如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造器的访问方式和普通类一样。
由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。
父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。
在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。

抽象方法：
如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，
那么你可以在父类中声明该方法为抽象方法。
abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。
抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。

public abstract class Demo{                    // 抽象类
	......
	public abstract double test();  // 抽象方法，只有名字，没有方法体，
	......
{

声明抽象方法会造成以下两个结果：
1、如果一个类包含抽象方法，那么该类必须是抽象类。
2、任何子类必须重写父类的抽象方法，否则，该子类也必须声明为抽象类。
最终，必须由子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。

抽象类总结规定：
1. 抽象类不能被实例化。只有抽象类的非抽象子类可以创建对象。

2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

4. abstract不能修饰属性、构造器等结构，不能用来修饰私有方法、静态方法、final方法、final类

5. 抽象类的子类必须给出抽象类中所有的抽象方法的具体实现，除非该子类也是抽象类。

匿名子类：
public abstract class Demo{ }   抽象类型
Demo d = new Demo(){ // 实现抽象类的抽象方法 }
匿名子类的匿名对象：
fun(new Demo(){ // 实现抽象类的抽象方法 });


接口Interface：
主要用来描述类具有什么功能，而并不给出每个功能的具体实现，需要类实现（implement）具体功能

在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。
一个类通过继承接口的方式，从而来继承接口的抽象方法。

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

接口无法被实例化（不能定义构造器），但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。
另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

接口特性：
接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。
接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。
接口中的方法是不能在接口中实现的，只能由实现接口的类来实现

接口与类相似点：
一个接口可以有多个方法。
接口文件保存在 .java 结尾的文件中，文件名使用接口名。
接口的字节码文件保存在 .class 结尾的文件中。
接口相应的字节码文件必须在与包名称相匹配的目录结构中。

接口与类的区别：
接口不能用于实例化对象。
接口没有构造方法。
接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。
接口不能包含成员变量，除了 static 和 final 变量。
接口不是被类继承了，而是要被类实现。
接口支持多继承。

抽象类和接口的区别：
1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。
注：JDK 1.8 以后，接口里可以有静态方法和方法体了。
注：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为"默认方法"，默认方法使用 default 关键字修饰。
注：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去

接口声明：
[修饰符] interface 接口名称 [extends 其他的接口名] {   
       void eat();                    // 需要类实现具体方法，隐式指定为 public abstract
        int a = 1；                  // 声明变量，隐式声明为 public static final 常量
       static void m(){ ...... }        // 静态方法，里面有方法体，只能通过接口调用
       default void m1(){ m(); }    // 默认方法，必须使用default修饰符，内部可以调用任何方法，可以重写，子类继承的父类中有同名同参方法，则调用父类的
                                                  继承两个接口，都有同名同参默认方法，报错，或重写
}
接口可以多继承接口：
interface A extends B，C... { }
A a;   // 接口可以声明为变量，但不能使用new，接口变量必须引用实现了接口的类的对象

接口冲突：类实现的两个接口中有两个相同的方法，报错：class A implements B，C... { }
解决：重写，或在类中显示调用对应接口的方法：接口.super.方法()

"类优先"规则：超类跟接口有相同的方法，则选择超类的方法

接口有以下特性：
接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字
接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字
接口中的方法都是公有的（public）

实现接口：
当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。
类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。
public class A implements B，C... {
	public void eat(){
                     // 方法的具体实现，必须声明为public
	}
 }

先继承后接口：
public class 类名 extends 父类 implements 接口1，接口2... { } 

接口实际就是定义了一种规范

抽象类能实现接口

抽象类能继承非抽象类

标记接口：
最常用的继承接口是没有包含任何方法的接口。
标记接口是没有任何方法和属性的接口，它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。

标记接口作用：
唯一作用就是允许在类型查询中使用instanceof：if(obj instanceof 标记接口)

标记接口主要用于以下两种目的：
1、建立一个公共的父接口：
正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。
例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。
2、向一个类添加数据类型：
这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，
但是该类通过多态性变成一个接口类型。

代理模式（Proxy）：
为其他对象提供一种代理以控制这个对象的访问，有点像python装饰器
静态代理，动态代理，jvm自带动态代理

工厂模式（Factory）：
实现了创建者和调用者分离，将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的
核心：
实例化对象，用工厂方法代替new操作
将选择实现类、创建对象统一管理和控制，从而将调用者跟我们的实现类解耦


代理类实在程序运行过程中创建的，一旦被创建，就变成了常规类


内部类：
1、成员内部类，可以调用外部类的方法
2、局部内部类（方法内，代码块内，构造器内）
class A{
    int age = 18;
    
    class B{                // 成员内部类
        int age = 19;
        this.age;         // 调用内部类属性 
        A.this.age;     // 调用外部类属性
     }    
    
    static class B{ }  // 静态成员内部类，可以有静态域和方法
    
    public A getAa(){  
         int a = 1;  
         class BB{         // 局部内部类，开发中常用这种，不能用public或private修饰
             int a = 2;    // 要求声明为final，jdk8后可以省略final
             }       
         return new A();  // 此方法返回一个A实例对象，不能返回BB的实例对象
    }
}

实例化内部类：
A.B obj = new A.B();   // 静态成员内部类
A a = new A();
A.B obj = a.new B();  // 成员内部类

内部类跟外部类有重名冲突解决：
在内部类使用this.age，而调用外部类的属性用A.this.age

内部类的所有静态域都必须是final
内部类被翻译成“外部类$内部类.class”文件，以$符分隔
内部类不需要访问外围对象的时候，应该使用静态内成员部类
声明在接口中的内部类自动成为static和public类


Java 枚举(enum)
Java 枚举是一个特殊的类，一般表示一组常量
Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。

实例：
enum Color{
    RED, GREEN, BLUE;
}
 
public class Test{
    public static void main(String[] args){
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}

内部类中使用枚举：
public class Test{
    enum Color{
        RED, GREEN, BLUE;
    }
 
    public static void main(String[] args){
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}

每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。
class Color
{
     public static final Color RED = new Color();
}

迭代枚举元素：
......
for (Color myVar : Color.values()) {
      System.out.println(myVar);
    }
......

values() 返回枚举类中所有的值。
ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。
valueOf()方法返回指定字符串值的枚举常量。

枚举类成员:
枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。
枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。
......
 public static void main(String args[]) {
		Color c1 = Color.RED;   // 自动执行枚举构造函数
   }
......
enum Color{
    RED, GREEN, BLUE;
 
    // 构造函数
    private Color(){
        System.out.println("Constructor called for : " + this.toString());
    }
 
    public void colorInfo(){
        System.out.println("Universal Color");
    }
}

执行结果：
Constructor called for : RED
Constructor called for : GREEN
Constructor called for : BLUE

Java 包(package):
为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间

包的作用:
1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字
     是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、
枚举（enumerations）和注释（annotation）等。

包名用小写，是标识符

包名命名规则：
建议使用公司域名逆序方式，因为域名是独一无二的
如，com.公司、com.公司.子包

包语句的语法格式为：
package pkg1[．pkg2[．pkg3…]];   // 一个点代表一层文件目录

例如,一个Something.java 文件它的内容
package net.java.util;  // 将类放入包中

public class Something {
   ...
}
那么它的路径应该是 net/java/util/Something.java 这样保存

import 导包:
在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前

import package1[.package2…].(classname|*);  // 导入指定包下的类或接口
同一个包下的类或接口不用导入

可以使用的类：所属包中的所有类，其他包中公有类（public class）

不能这样导入：import java.*.*;

java5后不需要设置类路径：CLASSPATH


Java 数据结构：
Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：

枚举（Enumeration）
位集合（BitSet）
向量（Vector）
栈（Stack）
字典（Dictionary）
哈希表（Hashtable）
属性（Properties）

枚举（Enumeration）
枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 
枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。
例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。

位集合（BitSet）
位集合类实现了一组可以单独设置和清除的位或标志。
该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一"位"，然后对位进行适当的设置或清除，
就可以对布尔值进行操作了。

向量（Vector）
向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。
和数组一样，Vector对象的元素也能通过索引访问。
使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。

栈（Stack）
栈（Stack）实现了一个后进先出（LIFO）的数据结构。
你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。
当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。

字典（Dictionary）
字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。
当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。
由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。

哈希表（Hashtable）
Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。
例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。
哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。

属性（Properties）
Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。
Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。


集合框架：
Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。
集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。
集合框架的类和接口均在java.util包中。
任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。

Collection接口：
所有实现了此接口的类都要提供下列方法（一部分）
iterator()        返回一个迭代器
size()
isEmpty()
contains(Object obj)                 集合中是否包含obj对象
containsAll(Collection<?> c)     是否包含集合c中的所有元素
equals(Object other)
boolean add(E e)           向集合添加元素
addAll(Collection<? extends E> other)    将other集合中的所有元素添加   
remove(Object obj)
removeAll(Collection<?> c)
clear()
retainAll(Collection<?> c)    删除不等于集合c中的所有元素
toArray()                              返回这个集合的对象数组
toArray(T[] arrayToFill)         返回数组并填充到arrayToFill，其余填充null，不够大，则创建新的数组
hashCode()
default boolean removeIf(Predicate<? super E> filter)  jdk8 默认方法，删除某个满足条件的元素

集合框架中的接口：
Iterable
    Collection
        List
        Set
            SortedSet
                NavigableSet
        Queue
            Deque
Map
    SortedMap
        NavigableMap
Iterator                  
    ListIterator
RandomAccess    标记接口 

集合类型：
ArrayList       一种可以动态增长和缩减的索引序列
LinkedList    一种可以在任何位置进行高效的插入和删除操作的有序序列
ArrayDeque  一种用循环数组实现的双端队列
HashSet    一种没有重复元素的无序集合
TreeSet   一种有序集
EnumSet  一种包含枚举类型的集
LinkedHashSet  一种可以记住元素插入次序的集合
PriorityQueue  一种允许高效删除最小元素的集合
HashMap  一种键、值关联的数据结构，python中的字典
TreeMap  一种键值有序排列的映射表
EnumMap  一种键值属于枚举类型的映射表
LinkedHashMap  一种可以记住键值添加次序的映射表
WeakHashMap  一种其值无用武之地后可以被垃圾回收器回收的映射表
IdenityHashMap  一种用 == 而不是用 equals 比较键值的映射表
以Map结尾的实现了Map接口，其他类则实现了Collection接口

Collections类：
Collections.replaceAll(list, "old", "new");   // 将list集合里面的old全部替换成new  
sort()方法可以对实现了List接口的集合进行排序
binarySearch()  二分查找，必须是有序的

ArrayList类：
数组列表，非同步的，而Vector类是同步的
ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制
ArrayList<Integer> li=new Arraylist<>();     // 存放整数元素，jdk7后可以省略后面尖括号里的Integer
ArrayList<Character> li=new Arraylist<>(100);   // 存放字符元素，也可以传递初始容量100

import java.util.ArrayList;       // 导入 ArrayList 类
import java.util.Collections;
ArrayList<String> s = new ArrayList<>();    存放字符串类型
s.add(int n, "a");     // 指定位置添加，不能在size为0的时候使用n参数，不加参数n在末尾添加
s.get(2);                 // 根据索引获取第二个元素
s.set(2, "b");           // 按索引设置值，如果对应位置没有值，则报错，即不能用set添加
s.remove(2);          // 删除索引处的值
s.size();                 // 元素个数
for (String i : s) {   
            System.out.println(i);  // 遍历
        }
Collections.sort(s);      排序,升序
......

方法	描述
add()	将元素插入到指定位置的 arraylist 中
addAll()	添加集合中的所有元素到 arraylist 中
clear()	删除 arraylist 中的所有元素
clone()	复制一份 arraylist
contains()	判断元素是否在 arraylist
get()	通过索引值获取 arraylist 中的元素
indexOf()	返回 arraylist 中元素的索引值
removeAll()	删除存在于指定集合中的 arraylist 里的所有元素
remove()	删除 arraylist 里的单个元素
size()	返回 arraylist 里元素数量
isEmpty()	判断 arraylist 是否为空
subList()	截取部分 arraylist 的元素
set()	替换 arraylist 中指定索引的元素
sort()	对 arraylist 元素进行排序
toArray()	将 arraylist 转换为数组
toString()	将 arraylist 转换为字符串
ensureCapacity()	设置指定容量大小的 arraylist
lastIndexOf()	返回指定元素在 arraylist 中最后一次出现的位置
retainAll()	保留 arraylist 中在指定集合中也存在的那些元素
containsAll()	查看 arraylist 是否包含指定集合中的所有元素
trimToSize()	将 arraylist 中的容量调整为数组中的元素个数
removeRange()	删除 arraylist 中指定索引之间存在的元素
replaceAll()	将给定的操作内容替换掉数组中每一个元素
removeIf()	删除所有满足特定条件的 arraylist 元素
forEach()	遍历 arraylist 中每一个元素并执行特定操作

LinkedList类:
链表（Linked list）一种基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，
而是在每一个节点里存到下一个节点的地址。
LinkedList类实现了List接口

import java.util.LinkedList;   导入
LinkedList<String> s = new LinkedList<>();
s.add("xxx");         末尾添加
s.addFirst("xx");    在头添加， removeFirst，getFirst   
s.addLast("xx");     在尾添加，
s.size();                 链表元素个数，用于遍历
for (String i : s) {
            System.out.println(i);
        }
System.out.print(s);  打印链表
s.subList(2, 4).clear();     // 删除链表 [2, 4) 区间的元素

listIterator<String>it = s.listIterator();   // 迭代器
it.add("xx")  添加元素到迭代器当前位置，it.next()将返回刚刚添加的元素
it.set("xx")   设置，添加
两个迭代器并发调用it.next()，后一个将会抛出异常，解决方法：一个共享计数值，每个it有有一
个独立的计数值，调用next方法时比较两个值是否相等，不一致则抛出异常

方法	描述
public boolean add(E e)	链表末尾添加元素，返回是否成功，成功为 true，失败为 false。
public void add(int index, E element)	向指定位置插入元素。
public boolean addAll(Collection c)	将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。
public boolean addAll(int index, Collection c)	将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。
public void addFirst(E e)	元素添加到头部。
public void addLast(E e)	元素添加到尾部。
public boolean offer(E e)	向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。
public boolean offerFirst(E e)	头部插入元素，返回是否成功，成功为 true，失败为 false。
public boolean offerLast(E e)	尾部插入元素，返回是否成功，成功为 true，失败为 false。
public void clear()	清空链表。
public E removeFirst()	删除并返回第一个元素。
public E removeLast()	删除并返回最后一个元素。
public boolean remove(Object o)	删除某一元素，返回是否成功，成功为 true，失败为 false。
public E remove(int index)	删除指定位置的元素。
public E poll()	删除并返回第一个元素。
public E remove()	删除并返回第一个元素。
public boolean contains(Object o)	判断是否含有某一元素。
public E get(int index)	返回指定位置的元素。
public E getFirst()	返回第一个元素。
public E getLast()	返回最后一个元素。
public int indexOf(Object o)	查找指定元素从前往后第一次出现的索引。
public int lastIndexOf(Object o)	查找指定元素最后一次出现的索引。
public E peek()	返回第一个元素。
public E element()	返回第一个元素。
public E peekFirst()	返回头部元素。
public E peekLast()	返回尾部元素。
public E set(int index, E element)	设置指定位置的元素。
public Object clone()	克隆该列表。
public Iterator descendingIterator()	返回倒序迭代器。
public int size()	返回链表元素个数。
public ListIterator listIterator(int index)	返回从指定位置开始到末尾的迭代器。
public Object[] toArray()	返回一个由链表元素组成的数组。
public T[] toArray(T[] a)	返回一个由链表元素转换类型而成的数组。

以下情况使用 ArrayList :
频繁访问列表中的某一个元素。
只需要在列表末尾进行添加和删除元素操作。

以下情况使用 LinkedList :
你需要通过循环迭代来访问列表中的某些元素。
需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。

HashSet：
HashSet 基于 HashMap 来实现的，是一个元素唯一不重复的集合。
HashSet 允许有 null 值。
HashSet 是无序的，即不会记录插入的顺序。
HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 
    您必须在多线程访问时显式同步对 HashSet 的并发访问。
HashSet 实现了 Set 接口

import  java.util.HashSet;    导入
HashSet<Integer> s = new HashSet<Integer>();   实例化
s.add(12);          添加
s.remove(12);    删除
s.size();              元素个数
s.clear();            清空
for(int i: s){        遍历
	System.out.println(i);
}

HashMap：
HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。
HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。
HashMap 是无序的，即不会记录插入的顺序。
HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。

HashMap 的 key 与 value 类型可以相同也可以不同

import java.util.HashMap;  导入
HashMap<Integer, String> s = new HashMap<Integer, String>();  实例化
s.put(1, "xxx");   添加
s.get(1);             根据key获取值
s.remove(key);   根据key删除
s.keySet();          所有key
s.values();           所有值
System.out.println(s);    打印，{1=xxx, 2=xxx}

方法	描述
clear()	删除 hashMap 中的所有键/值对
clone()	复制一份 hashMap
isEmpty()	判断 hashMap 是否为空
size()	计算 hashMap 中键/值对的数量
put()	将键/值对添加到 hashMap 中
putAll()	将所有键/值对添加到 hashMap 中
putIfAbsent()	如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。
remove()	删除 hashMap 中指定键 key 的映射关系
containsKey()	检查 hashMap 中是否存在指定的 key 对应的映射关系。
containsValue()	检查 hashMap 中是否存在指定的 value 对应的映射关系。
replace()	替换 hashMap 中是指定的 key 对应的 value。
replaceAll()	将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。
get()	获取指定 key 对应对 value
getOrDefault()	获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值
forEach()	对 hashMap 中的每个映射执行指定的操作。
entrySet()	返回 hashMap 中所有映射项的集合集合视图。
keySet()	返回 hashMap 中所有 key 组成的集合视图。
values()	返回 hashMap 中存在的所有 value 值。
merge()	添加键值对到 hashMap 中
compute()	对 hashMap 中指定 key 的值进行重新计算
computeIfAbsent()	对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中
computeIfPresent()	对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。


Iterator（迭代器）：
Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。
Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。

四个方法： next 、hasNext 、remove、forEachRemaining
调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。到达末尾抛出NoSuchElementException
调用 it.hasNext() 用于检测集合中是否还有元素。
调用 it.remove() 将迭代器返回的元素删除。
jdk8调用it.forEachRemaining( lambda表达式 )；将对每个元素调用lambda表达式

import java.util.Iterator;  导入

ArrayList<String> s = new ArrayList<>();  
Iterator<String> it = s.iterator();     // 迭代器
while(it.hasNext()){ 
     it.next();             迭代获取每一个元素    
     it.remove();        删除元素, 先调用next()，再调用remove()，否则报错   
}

for( String e: s ){}   // “for each”循环可以与任何实现了Iterable接口的对象一起工作

集合与数组的转换：
toArray(集合)
Arrays.asList(数组)
String[ ] arr = s.toArray(new String[0]);   // 集合转数组，默认返回Object[]数组，加上new String[0]则创建相同的数组类型
HashSet<String> s = new HashSet<>(Arrays.asList(arr))；    // 数组转集合


Object 类：
Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。

Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，
那么它就会自动继承 Object，成为 Object 的子类。

Object 类可以显示继承，也可以隐式继承

方法：
protected Object clone()     创建并返回一个对象的拷贝
boolean equals(Object obj)  比较两个对象是否相等

null 不等于 ""，"".length() 为0

protected void finalize() 当 GC (垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。

Class<?> getClass() 获取对象的运行时对象的类

int hashCode() 获取对象的 hash 值

void notify() 唤醒在该对象上等待的某个线程

void notifyAll() 唤醒在该对象上等待的所有线程

String toString() 返回对象的字符串表示形式

void wait() 让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。

void wait(long timeout)
让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，
或者超过参数设置的timeout超时时间。

void wait(long timeout, int nanos)
与 wait(long timeout) 方法类似，多了一个 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 
所以超时的时间还需要加上 nanos 纳秒。


三种JVM：
Sun公司的HotSpot
BEA公司的JRockit
IBM公司的J9 VM
java -version查看


String：
String字符串，一对双引号内，声明为final，不可被继承
实现了Serializable接口：表示字符串支持序列化
实现了Comparable接口：表示String可以比较大小
内部定义了final char[ ] value 数组用于存储字符串数据
不可变的，重新赋值、"+"号连接、替换、任何修改都会重新开辟内存区域
通过字面量方式赋值（非new），字符串将存放在字符串常量池中，字符串常量池中不会存储两个相同的内容

"abc".equals("abc")     // true，比较两个字符串是否相等
"xabc".substring(0,3) == "xab"   // false，不建议使用 "=="，因为截取或"+"的字符串会放在不同的地方
String str = "a";
"x" + str == "xa";      // false，字符串+变量的方式为false
"x" + "a" == "xa";     // true，字符串+字符串则为true

赋值方式：
String s = "xxx";   // 放在常量池
String s = new String(char[ ] a);
String s1 = new String("xxx");   // 放在堆，new两个相同的，==比较为false，equals比较为true
                                               // 创建了两个对象：一个是堆空间new结构，一个是char[ ]对应常量池数据"xxx"
结论：
1、常量跟常量拼接（加+）结果在常量池
2、只要有一个是变量，结果就在堆中
3、如果拼接的结果调用intern()方法，返回值就在常量池中：String s = (s1 + s2).intern();
4、用final修饰的也存在常量池

常用方法：
String s = "abcdffg";
s.length()               字符串长度
charAt(index)         返回索引处的字符
isEmpty()               判断是否空串
toLowerCase()        转小写
toUpperCase()        大写
trim()                     返回新字符串，去除前后空白
equals("xxx")         比较是否相等
equalsIgnoreCase("xxx")    跟equals一样，但忽略大小写
concat("xxx")         拼接
compareTo()         比较大小，小于：负数，等于：0，大于：正数 
substring(index，endIndex)     指定位置开始截取，不指定endIndex则到截取到末尾，左闭右开
startWith("xxx"，2)    判断以什么开头，从位置2开始判断，endsWith("xx")，没有第二个参数  
contains("xx")           是否包含"xxx"
indexOf("xx"，2)       首次出现的位置，从位置2开始，返回xx索引，否则返回-1
lastIndexOf("xx"，3)  最后出现的，可选参数3，从指定位置向开头查找
replace(old, new)       全部替换
replaceAll(正则，"xxx")  将匹配到的内容替换为xxx，replaceFirst(正则，"xx")  替换第一个
matches(正则)               布尔值，是否匹配对应的正则
split(正则，int)              拆分，返回数组，可选参数int，指定拆分int-1次

字符串是不可变的，跟python一样

字符串跟基本数据类型转换：
String s = "12";
int num = Integer.parseInt(s);     // 转换为整型，Double.parseDouble(s):转换为double类型，其他类似parseXxx 
String.valueOf(12);                     // 转为字符串

char[ ]跟String转换：
s.toCharArray()          // 转为char[ ]数组，一个字母一个字母
char[ ] arr = new char[ ]{'a', 'b'};      
String s = new String(arr);      //  char[ ]  转为 String   

byte[] 跟String转换：
字节 ---> 字符串    解码
String ---> byte    编码
s.getByte("utf-8");             // 返回byte[ ]数组，可以指定编码: 一个汉字：utf-8占三个字节，gbk两个字节
Arrays.toString(bytes);      // 转为String
String s = new String(barr，"utf-8");   // 转为String，可选解码集

StringBuffer，StringBuilder:
可变的字符序列
StringBuffer：
线程安全的，效率低，底层使用char[ ]存储，默认char[16]，不够会重新创建一个两倍长度+2的
数组，复制原来的元素进去，这样就是可变的了。
StringBuffer s = new StringBuffer(18);      // 初始化时可以指定长度

StringBuilder： 
jdk5，线程不安全，效率高，底层使用char[ ]存储，StringBuilder s = new StringBuilder()

String：
不可变序列final，底层使用char[ ]存储，默认char[0]

StringBuffer常用方法：StringBuilder的方法也一样
增、删、改、查、插、长度、遍历
append(xxx)                  追加，整型字符串都行
delete(start, end)           删除区间内容
replace(start，end，"xxx")     替换指定区间内容
insert(4，"xx")              指定位置插入
reverse()                       反转
indexOf("xx")                获取字符索引
substring(start，end)    截取                    
length()                        长度
charAt(4)                      获取指定位置字符
setCharAt(4)                 设置指定位置字符

效率：StringBuilder > StringBuffer > String


Java 泛型:
Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，
该机制允许程序员在编译时检测到非法的类型。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

最常用的类型参数名称是：
E - 集合的元素类型（被 Java 集合框架广泛使用）
K - 键
V - 值
N - 数字
T - 任意类型（还可以使用邻近字母S、U）

泛型方法:                         
public static <T> void m( T... arr )  // 类型变量<E>放在修饰符的后面，返回类型的前面
 {          
         for ( T t : arr ){        
            System.out.println(t);
         }
 }

调用：
类名.<Integer>m(1, 3, 4, 5);   // 可以省略<Integer>，即：类名.m(1, 3, 4, 5);

泛型类:
泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。
和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。
一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一
个或多个参数，这些类被称为参数化的类或参数化的类型。

可以看作普通工厂类

public class Box<T> {    

  private T t;

  public void add(T t) {
    this.t = t;
  }
 
  public T get() {
    return t;
  }
 
  public static void main(String[] args) {
    Box<Integer> integerBox = new Box<Integer>(); 
    integerBox.add(10);     // 自动装箱
    System.out.print( integerBox.get() ); 
  }
}

Java SE 7 及更高版本中，<>只要编译器可以从上下文中确定或推断类型参数，
就可以将调用泛型类的构造函数所需的类型参数替换为空的类型参数集 ( )。
Box<Integer> integerBox = new Box<>();

类型变量限定：
传入类型不能超过限定的类型
public static <T extends Number & Comparable> void m(){}  // 多个限定用 "&" 分隔

虚拟机中没有泛型，只有普通的类跟方法。
所有的类型参数都用它们的限定类型替换。
桥方法被合成来保持多态。
为保持类型安全，必要时插入强制类型转换。

虚拟机中泛型类型的擦除:
在虚拟机中会去掉<T>、<String>......
去掉<T>就变为普通类了，内部的所有“T”都要改为“Object”，成为原始类
<T extends Number & Comparable>  则用第一个限定的类型替换，即：“T”改为“Number”

约束与局限性：
不能用基本类型实例化类型参数，即：ArrayList<int> = new ......
运行时类型查询只适用于原始类型，即：a instanceof P<String> ......，p.getClass()返回擦除类型后的:P.class
不能创建参数化类型的数组，即：P<String>[] p = new P<>[10];  不支持泛型类型的数组
不能构造泛型数组
泛型类的静态上下文中类型变量无效，即：private static T a；
不能抛出或捕获泛型类的实例，即：cath(T e)，扩展Throwable也不行：class A<T> extends Exception{}
注意擦除后的冲突

泛型类型的继承规则：
class B extends A
ArrayList<B>不是一个ArrayList<A>

类型通配符:
B<? extends A>  表示任何泛型B类型，它的类型参数都是A的子类。子类限定。
C<? super B>     限定为A的所有超类。超类限定。
B<? extends A<? super T>>
C<?>                 无限定通配符

B<? extends A> obj = new Xx<>();
1、类型通配符一般是使用?代替具体的类型参数。例如 List<?> 在逻辑上是List<String>,List<Integer> 等
     所有List<具体类型实参>的父类。
2、类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。
     List<? extends Number>
3、类型通配符下限通过形如 List<? super Number>来定义，表示类型只能接受Number及其三层父
     类类型，如 Object 类型的实例。

带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。


Java 序列化：  
（对象序列化进文件，从文件反序列化对象出来）
Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、
有关对象的类型的信息和存储在对象中数据的类型。

将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，
还有对象中的数据类型可以用来在内存中新建对象。

整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。

类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。


网络编程（socket）：
import java.net.Socket;
import java.net.ServerSocket;

实例
import java.net.*;
 
public class T{
   public static void main(String[] args){
     try{
		System.out.print(InetAddress.getByName("www.baidu.com"));  // 获取主机跟ip地址
		InetAddress.getLocalHost()； 本地IP地址跟计算机名

		URL url = new URL("https://www.baidu.com");  // 创建请求url
		URLConnection con = url.openConnection();  // 发送请求
		con.getContentLength()；  // 获取大小（字节）
		con.getInputStream().close();  // 关闭

		Socket s = new Socket("www.baidu.com", 80);  // 连接到指定主机
		s.getInetAddress();  // 获取ip
		s.close();		

     }catch(Exception e){
		 System.out.println(e);
	 }
   }
}


发送邮件:
1、首先安装 JavaMail API 和Java Activation Framework (JAF) 
2、从 Java 网站下载最新版本的 JavaMail,最新版本的 JAF
3、下载并解压缩这些文件，在新创建的顶层目录中，您会发现这两个应用程序的一些 jar 文件。
您需要把 mail.jar 和 activation.jar 文件添加到您的 CLASSPATH 中。

如果你使用第三方邮件服务器如QQ的SMTP服务器，还要用户认证
用户认证部分：
如果需要提供用户名和密码给e-mail服务器来达到用户认证的目的，你可以通过如下设置来完成：
props.put("mail.smtp.auth", "true");
props.setProperty("mail.user", "myuser");
props.setProperty("mail.password", "mypwd");

关于QQ邮箱，还要设置SSL加密，加上以下代码即可：
MailSSLSocketFactory sf = new MailSSLSocketFactory();
sf.setTrustAllHosts(true);
props.put("mail.smtp.ssl.enable", "true");
props.put("mail.smtp.ssl.socketFactory", sf);


Java 多线程编程：
Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程
中可以并发多个线程，每条线程并行执行不同的任务。
多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。
进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，
它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。
多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。

进程：资源分配的单位
线程：调度和执行的单位

Thread.sleep(毫秒);   将当前线程睡眠，静态方法，需要用try-catch捕获InterruptedException（中断线程）

创建一个线程：
Java 提供了四种创建线程的方法：

1、通过实现 Runnable 接口（推荐）
2、通过继承 Thread 类本身（不推荐）  
3、通过 Callable 和 Future 创建线程。jdk5新增
4、线程池

1、通过实现 Runnable 接口：
1）创建一个类实现Runnable接口
2）实现Runnable接口中的抽象方法run()
3）创建对象
4）将此对象作为参数传递到Thread类的构造器中，创建Thread类对象
5）通过Thread类的对象调用start()方法

方式一：
class R implements Runnable {
    public void run(){
        for(int i = 100; i > 0; i--){
            System.out.println(i);
        }
    }
}

public class M {
    public static void main(String[] args) {
        R r = new R();
        Thread t = new Thread(r);     // 创建线程
        t.start();
    }
}

方式二：
Runnable r = () -> { System.out.println("xxx"); };
Thread t1 = new Thread(r);


2、通过继承Thread来创建线程：
1）创建类继承Thread类
2）重写Thread类的 run() 方法，该方法是新线程的入口点。
3）创建Thread类的子类对象，必须调用 start() 方法才能执行。
该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例

class T extends Thread {
	public void run(){	
		for(int i = 100; i > 0; i--){
			System.out.println(this.getName());  // 获取线程名称，默认Thread-0
		}
	}
}

public class M {
   public static void main(String args[]) {
	 T t = new T();    // 创建线程
	 t.setName("t1111");            // 设置名称
	 t.start();

                // 匿名方式
                new Thread() {
                    public void run() {
                        for (int i = 100; i > 0; i--) {
                            System.out.println("aa");  // 获取名称
                        }
                    }
                }.start();
   }   
}

Thread类的一些重要方法：
是被 Thread 对象调用的
start()：启动当前线程；Java 虚拟机调用当前线程的 run 方法。
run()：通常需要重写Thread类中的run方法，将创建的线程要执行的操作声明在此方法中。
          如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；
          否则，该方法不执行任何操作并返回。

t.join()； 在线程a中执行线程b的join()方法，此时线程a进入阻塞状态，直到线程b执行完后，线程a才结束阻塞状态
join(long millisec)   同上，或时间为millis 毫秒。
setName(String name)  改变线程名称，使之与参数 name 相同。
setPriority(int priority)  更改线程的优先级，默认优先级5，等级1~10
setDaemon(boolean on)  将该线程标记为守护线程或用户线程。
interrupt()  中断线程。
isAlive()    测试线程是否处于活动状态。

stop();  强制停止进程，已弃用

Thread 类的静态方法：
yield()  让步，暂停当前正在执行的线程对象，并执行其他线程。
sleep(long millisec)  在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。
holdsLock(Object x)  当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。
currentThread()  返回对当前正在执行的线程对象的引用（Thread），Thread.currentThread().getName()：返回当前线程名称
dumpStack()  将当前线程的堆栈跟踪打印至标准错误流。

线程通信的三个方法：
在Object类中
1、wait()        使当前线程进入阻塞状态，并释放同步监视器（锁）
2、notify()     唤醒wait的一个线程，多个则唤醒优先级高的
3、notifyAll() 唤醒所有wait的线程
这三个方法必须使用在同步代码块或同步方法中
调用者必须是同步代码块或同步方法中的同步监视器，否则出现异常，默认this.wait().....

sleep()和wait()异同：
相同点：一旦方法执行，都可以使当前线程进入阻塞状态
不同点：
声明位置不同，Thread类中声明sleep，Object类中声明wait。
调用要求不同，sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中。
是否释放同步监视器（锁）：如果两个方法都使用在同步代码块或同步方法中，sleep不会释放，wait会释放。

Runnable和Thread对比：
开发中优先选择实现Runnable接口方式，实现的方式没有类的单继承的局限性，实现的方式更适合来处理多个线程
共享数据的情况。
Thread类本身是实现了Runnable接口：public class Thread implements Runnab
两种方式都需要重写run()，将线程要执行的逻辑声明在run()中

继承Thread类，共享变量要用static，相当于锁
实现Runnable接口不用

3、实现Callable接口:
它可以有返回值，且支持泛型的返回值，方法可以抛出异常。需要借助FutureTask类，比如获取返回结果。
1、创建类实现Callable 接口
2、实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
3、创建 Callable 实现类的对象
4、使用 FutureTask 类来包装 Callable的对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
5、使用 FutureTask 对象作为 Thread 对象的 target 创建并start()启动新线程。
调用 FutureTask 对象的 get() 方法可以获得子线程执行结束后的返回值。

实例：
import java.util.concurrent.Callable;  // 导入
class T implements Callable{
    public Object call() throws Exception{   
        // 线程要做的事，放在这里
        for(int i = 100; i > 0; i--){
            System.out.println(Thread.currentThread().getName());  // 获取线程名称，默认Thread-0
        }
        return null;   // 可以有返回值
    }
}

public class M {
    public static void main(String args[]) {
        T t = new T();    
        FutureTask f = new FutureTask(t);
        Thread thr = new Thread(f);
        t.start();
        f.get();  // 获取返回值，阻塞，直到有返回值
    }
}

实现Callable接口比实现Runnable接口创建线程的方式要强大

4、线程池方式创建线程：
提前创建多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免重复创建、销毁，实现重复利用。
class T implements Callable{
    public Object  call(){                        // Callable
        // 线程要做的事，放在这里
        for(int i = 10; i > 0; i--){
            System.out.println(Thread.currentThread().getName());  // 获取线程名称，默认Thread-0
        }
        return null;
    }
}

public void  run(){                             // Runnable
        // 线程要做的事，放在这里
        for(int i = 10; i > 0; i--){
            System.out.println(Thread.currentThread().getName());  // 获取线程名称，默认Thread-0
        }
    }

public class M {
    public static void main(String args[]) {
        ExecutorService s = Executors.newFixedThreadPool(10);   // 固定数量线程，空线程会一直保留
        s.execute(new T());  // 比较适用于Runnable
        s.submit(new T());  // 比较适用于Callable
        s.shutdown();  // 关闭线程池，先完成已经提交的任务，不再接收新任务
    }
}

Executors：
1、newCachedThreadPool()                 必要时创建新线程，空闲线程保留60秒，任务来时，没有空闲线程则创建新线程
2、newFixedThreadPool(5)                  固定数量线程，空线程会一直保留，任务满放入队列
3、newSingleThreadExecutor()            只有一个线程的线程池，顺序执行每一个提交的任务
4、newScheduledThreadPool(5)              用于预定执行而构建的固定线程池，替代java.util.Timer
5、newSingleThreadScheduledExecutor()  用于预定执行而构建的单线程池   

前三个方法返回实现了ExecutorService 接口的 ThreadPoolExecutor 类的对象。
后两个方法将返回实现了 ScheduledExecutorService 接口的对象。

注意：
1、如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了
2、创建了太多的线程，CPU 花费在上下文切换的开销时间将多于执行程序的时间
可以用线程池解决。

程序中创建了大量生命期很短的线程，应该使用线程池。

生命周期：
Thread.State类定义了线程的几种状态
新建
就绪
运行
阻塞
死亡

就绪跟运行可以相互转换
阻塞需要就绪才能的运行

线程安全问题：多个线程共同使用一个共享数据，可能会出现这种问题

java解决线程安全问题：
方法一：同步代码块
synchronized(同步监视器){       // 锁，任何一个类的对象都能称为锁，要求多个线程共用同一把锁
    // 需要被同步的代码，即操作共享数据的代码
}
好处：解决了线程安全问题
局限性：操作同步代码时，只能有一个线程参与，其他线程等待，相当于单线程，效率低

Runnable可以考虑使用this充当同步监视器
继承Thread类可以考虑使用当前类：MyClass.class

实例：
class R implements Runnable {

    private static Object obj = new Object();   // 锁，任何一个对象都行，但多个线程用的是同一个，只new一次
    
    synchronized(obj){       // 也可以使用this，或R.class，因为类只加载一次
        public void run(){
            for(int i = 100; i > 0; i--){
                System.out.println(i);
            }
        }
    }
}

public class M {
    public static void main(String[] args) {
        R r = new R();
        Thread t = new Thread(r);     // 创建线程
        t.start();
    }
}

方法二：同步方法
同步代码块正好在一个方法中

class R implements Runnable {          // 实现Runnable接口，继承Thread类，使用statc：private static synchronized void run(){ }
    public synchronized void run(){    // 同步监视器就是this
         for(int i = 100; i > 0; i--){
                    System.out.println(i);
         }
    }
}

继承Thread类方式，同步方法写成静态方法：
private static synchronized void run(){ }

方法三 Lock锁：
jdk5新增
import java.util.concurrent.locks.ReentrantLock;  // 导入
static ReentrantLock lock = new ReentrantLock();   // 继承Thread类，要使用static关键字创建lock对象
lock.lock();       // 上锁
...需要同步的代码
lock.unlock();  // 释放锁，放在finally子句比较好

优先使用顺序：
Lock-->同步代码块-->同步方法


Java 8 新特性 Lambda 表达式：
Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。
Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。
使用 Lambda 表达式可以使代码变的更加简洁紧凑。

语法格式：
(参数) -> 表达式；  // 无参也要括号：() ->xxx，只有一个参数可以省略括号
或
(参数) ->{ 语句; }    // 无需指定返回类型，根据上下文推导得出

相当于匿名函数，但不能使用变量接收
ArrayList：list.removeIf(e -> e==null);

特征：
可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。
可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。
可选的大括号：如果主体包含了一个语句，就不需要使用大括号。
可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。

注意：
Lambda 表达式主要用来定义行内执行的方法类型接
 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。
lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）

变量作用域：
lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内
部修改定义在域外的局部变量，否则会编译错误


Java 8 方法引用：
ArrayList<String> names = new ArrayList();
      names.add("Baidu");
      names.add("Sina");
      names.forEach(System.out::println);  // 等价于lambda： x -> System.out.println(x)
输出：
Baidu
Sina

跟lambda表达式一样，方法引用不能独立存在，总是会转换为函数式接口的实例
this::xxx
super::xxx

构造器引用，方法名为new，例如Person构造器引用：Person::new，根据上下文推导出使用哪个构造器
数组类型构造器int[ ]::new，参数是数组的长度，等价于lambda表达式 x ->new int[x]

lambda中，只能引用值不会改变的变量，如lambda表达式外for循环的i变量
this关键字表示创建这个lambda表达式的方法的this

java中，lambda表达式就是闭包

lambda表达式重点是延迟执行


Java 8 函数式接口:
lambda表达式传递到函数式接口

java8跟之前的日期转换：
java.sql.Date d = new java.sql.Date(new java.util.Date().getTime());


连接mysql：
Java 使用 JDBC 连接 MySQL 数据库
下载对应mysql数据库版本jar包，放入jdk8\jre\lib\ext下

1、打开链接选择对应数据库版本：http://dev.mysql.com/downloads/connector/j/
2、选择：Platform Independent，下载：mysql-connector-java-5.1.47.tar.gz，只有几M大小
3、解压后得到 jar库文件，将mysql-connector-java-5.1.47-bin.jar放入jdk8\jre\lib\ext下，
然后在对应的项目中导入该库文件。

代码：
import java.sql.*;  // 导入相关

public class M {
    static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";
    // static final String DB_URL = "jdbc:mysql://localhost:3306/数据库名?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC";	   
    static final String DB_URL = "jdbc:mysql://localhost:3306/数据库名";  // MySQL8.0一下版本使用这个
    static final String USER = "root";  // 用户名
    static final String PASS = "1234";  // 密码
 
   public static void main(String[] args) {    
        try{          
            Class.forName(JDBC_DRIVER);   // 注册 JDBC 驱动       
            Connection conn = DriverManager.getConnection(DB_URL,USER,PASS);   // 打开链接           
            
            Statement stmt = conn.createStatement();  // 执行查询
            ResultSet rs = stmt.executeQuery("SELECT * FROM admin");  			
            
            while(rs.next()){
	int id = rs.getInt("id");  // 根据类型获取数据：rs.getXxx("字段")，id为数据库字段名
	String name = rs.getString("name");
            }

           // 关闭		
           rs.close();
           stmt.close();
           conn.close();

        } catch(Exception e){
	  System.out.println(e);
       }
   }
}

JavaBean：
一种Java语言写成的可重用组件
符合如下标准：
1、类是公共的
2、有一个无参的公共的构造器
3、有属性，且有对应的get、set方法


部署java应用程序：
打包成jar文件
创建JAR文件：jar cvf xxx.jar file1.class file2.class
创建可运行的jar：
jar cvfe xxx.jar M M.class，指定程序入口点为M
或
创建xx.mf清单文件，输入：Main-Class: M，打包：jar cvfm xxx.jar xx.mf M.class
运行：java -jar xxx.jar

Java web start





